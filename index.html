<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leslie Speech Assistant</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background-color: #ffffff;
            color: #000000;
            overflow-x: hidden;
            touch-action: pan-y;
        }
        .container {
            max-width: 100vw;
            min-height: 100vh;
            padding: 16px;
            position: relative;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 16px;
        }
        .header h1 {
            font-size: 24px;
            font-weight: bold;
            color: #0099cc;
            flex-grow: 1;
            text-align: center;
        }
        .settings-btn {
            width: 48px;
            height: 48px;
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: 50%;
            padding: 8px;
            font-size: 20px;
        }
        .settings-btn:hover { background-color: #f0f0f0; }
        .page { display: none; width: 100%; }
        .page.active { display: block; }
        .home-page {
            text-align: center;
            padding: 16px;
        }
        .welcome-text {
            font-size: 18px;
            margin-bottom: 32px;
            line-height: 1.5;
        }
        .main-button {
            width: 100%;
            height: 80px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px;
            margin-bottom: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .main-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        .main-button:active { transform: translateY(0); }
        .btn-talking { background-color: #0099cc; }
        .btn-texting { background-color: #9933cc; }
        .btn-phone { background-color: #669900; }
        .btn-commands { background-color: #ff8800; }
        .tips-box {
            background-color: #f0f0f0;
            padding: 16px;
            border-radius: 8px;
            margin-top: 16px;
            line-height: 1.4;
            font-size: 14px;
            font-weight: bold;
        }
        .page-header {
            display: flex;
            align-items: center;
            padding: 16px;
            color: white;
            margin-bottom: 16px;
            border-radius: 8px;
        }
        .page-header h2 {
            flex-grow: 1;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
        }
        .close-btn {
            width: 48px;
            height: 48px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 50%;
            font-size: 24px;
        }
        .close-btn:hover { background-color: rgba(255,255,255,0.2); }
        .header-speech { background-color: #0099cc; }
        .header-phone { background-color: #669900; }
        .header-commands { background-color: #ff8800; }
        .header-text { background-color: #9933cc; }
        .header-settings { background-color: #0099cc; }
        .speech-page {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px);
            overflow-y: auto;
        }
        .status-text {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #0099cc;
            margin-bottom: 16px;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .speech-display {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 16px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .speech-header {
            background-color: #f0f0f0;
            padding: 8px;
            font-size: 14px;
            font-weight: bold;
            color: #0099cc;
        }
        .speech-content {
            padding: 12px;
            flex-grow: 1;
            max-height: 200px;
            overflow-y: auto;
            min-height: 150px;
        }
        .speech-text {
            font-size: 16px;
            line-height: 1.4;
            color: #000;
        }
        .final-phrase {
            background-color: #e3f2fd;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            border-left: 4px solid #0099cc;
        }
        .interim-phrase {
            background-color: #fff8e1;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            border-left: 4px solid #ffa000;
            color: #666;
            font-style: italic;
        }
        .enhanced-section {
            background-color: #f8f9fa;
            border: 2px solid #6f42c1;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            display: none;
        }
        .enhanced-section.show { display: block; }
        .enhanced-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .enhanced-title { font-size: 14px; font-weight: bold; color: #6f42c1; }
        .cost-info { font-size: 12px; color: #666; }
        .enhanced-status {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
            min-height: 20px;
        }
        .control-row {
            display: flex;
            justify-content: center;
            gap: 8px;
            align-items: center;
            margin: 16px 0;
            padding: 0 16px;
            position: sticky;
            bottom: 0;
            background: white;
            border-top: 2px solid #0099cc;
            padding-top: 16px;
        }
        .control-btn {
            height: 70px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            width: 300px;
            max-width: 80%;
        }
        .icon-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-listen { background-color: #0099cc; }
        .btn-stop { background-color: #cc0000; }
        .btn-enhanced { background-color: #6f42c1; }
        .btn-send { background-color: #669900; }
        .btn-keyboard { background-color: #99cc00; }
        .btn-clear { background-color: #ffaa00; }
        .btn-home {
            background-color: #0099cc;
            height: 70px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            width: 300px;
            max-width: 80%;
            margin: 0 auto;
            display: block;
        }
        .btn-disabled { background-color: #ccc !important; cursor: not-allowed !important; }
        .text-input {
            width: 100%;
            padding: 16px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 18px;
            resize: vertical;
            min-height: 120px;
            background: #f9f7fa;
        }
        .large-text-input {
            flex-grow: 1;
            min-height: 260px;
            margin-top: 8px;
        }
        .text-input-page {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px);
        }
        .text-input-content {
            flex-grow: 1;
            padding: 16px;
            padding-bottom: 100px;
            position: relative;
        }
        .speak-text-container {
            position: relative;
            margin-top: 16px;
        }
        .speak-phrase-btn {
            background: #9933cc;
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 4px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            position: absolute;
            right: 8px;
            top: -48px;
            z-index: 10;
        }
        .speak-phrase-btn:hover { background: #7a2a99; }
        .speak-phrase-btn:disabled { background: #ccc; cursor: not-allowed; opacity: 0.5; }
        .contact-search-section {
            padding: 12px;
            background-color: #f0f0f0;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .contact-search-input {
            width: 100%;
            height: 50px;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #669900;
            border-radius: 8px;
            margin-top: 8px;
        }
        .contact-list-container {
            padding: 8px;
            flex-grow: 1;
            max-height: 400px;
            overflow-y: auto;
        }
        .contacts-list {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            background-color: white;
            min-height: 300px;
        }
        .contact-item {
            padding: 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .contact-item:hover { background-color: #f0f0f0; }
        .contact-item.selected {
            background-color: #669900;
            color: white;
        }
        .contact-name {
            font-weight: bold;
            font-size: 16px;
        }
        .contact-phone {
            color: #666;
            font-size: 14px;
            margin-top: 2px;
        }
        .contact-item.selected .contact-phone { color: #fff; }
        .phone-home-section {
            padding: 16px;
            text-align: center;
            background-color: #f0f0f0;
            border-top: 2px solid #669900;
            margin-top: 16px;
        }
        .settings-section {
            background-color: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .settings-title {
            font-size: 16px;
            font-weight: bold;
            color: #000;
            margin-bottom: 8px;
        }
        .settings-description {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            margin-bottom: 8px;
        }
        .setting-value {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #0099cc;
        }
        .switch {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .switch input { margin-right: 8px; transform: scale(1.5); }
        .back-btn {
            width: 200px;
            height: 70px;
            background-color: #0099cc;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 16px auto 32px;
            display: block;
        }
        .weather-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 3px solid #0099cc;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            width: 90vw;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .weather-display.hidden { display: none; }
        .weather-title {
            font-size: 20px;
            font-weight: bold;
            color: #0099cc;
            text-align: center;
            margin-bottom: 16px;
        }
        .weather-content {
            margin-bottom: 16px;
            line-height: 1.6;
            text-align: center;
        }
        .weather-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .weather-btn {
            padding: 8px 16px;
            background: #0099cc;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .weather-btn:hover { background: #0077aa; }
        .hourly-forecast, .weekly-forecast {
            display: grid;
            gap: 8px;
        }
        .hourly-item, .weekly-item {
            background: #f0f8ff;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 12px;
        }
        .weekly-item {
            display: grid;
            grid-template-columns: 80px 60px 1fr;
            gap: 8px;
            align-items: center;
            font-size: 14px;
        }
        .day-name { font-weight: bold; }
        .day-temps { color: #0099cc; font-weight: bold; }
        .day-condition { color: #666; }
        .swipe-edge {
            position: fixed;
            z-index: 998;
            background: rgba(0,153,204,0.3);
        }
        .swipe-bottom {
            bottom: 0;
            left: 40%;
            width: 20%;
            height: 40px;
        }
        .swipe-left {
            left: 0;
            top: 40%;
            width: 40px;
            height: 20%;
        }
        .swipe-right {
            right: 0;
            top: 40%;
            width: 40px;
            height: 20%;
        }
        .api-key-section {
            background-color: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .api-key-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-top: 8px;
        }
        .contact-loading-section {
            padding: 20px;
            text-align: center;
            color: #669900;
            border: 2px solid #669900;
            border-radius: 8px;
            background-color: #f8f9fa;
            margin-bottom: 16px;
        }
        .voice-command-status {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(255, 193, 7, 0.9);
            color: #333;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            border: 2px solid rgba(255, 193, 7, 0.3);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .voice-command-status.active {
            background: rgba(40, 167, 69, 0.9);
            color: white;
            display: block;
            border-color: rgba(40, 167, 69, 0.3);
            animation: pulse 2s infinite;
        }
        .voice-command-status.permission-needed {
            background: rgba(220, 53, 69, 0.9);
            color: white;
            display: block;
            border-color: rgba(220, 53, 69, 0.3);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @media (max-width: 768px) {
            .container { padding: 8px; }
            .main-button { height: 70px; font-size: 18px; }
            .control-btn { width: 250px; }
            .weather-display { 
                padding: 16px;
                width: 95vw;
                max-width: 450px;
            }
            .voice-command-status {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Voice Command Status Indicator -->
        <div class="voice-command-status" id="voiceCommandStatus">üéôÔ∏è Voice Commands Ready</div>

        <!-- Swipe Edge Detection Areas -->
        <div class="swipe-edge swipe-bottom" id="swipeBottom"></div>
        <div class="swipe-edge swipe-left" id="swipeLeft"></div>
        <div class="swipe-edge swipe-right" id="swipeRight"></div>

        <!-- Weather Display -->
        <div class="weather-display hidden" id="weatherDisplay">
            <div class="weather-title" id="weatherTitle">Current Weather</div>
            <div class="weather-content" id="weatherContent">Loading weather data...</div>
            <div class="weather-controls">
                <button class="weather-btn" onclick="showCurrentWeather()">Current</button>
                <button class="weather-btn" onclick="showHourlyWeather()">24 Hours</button>
                <button class="weather-btn" onclick="showWeeklyWeather()">7 Days</button>
                <button class="weather-btn" onclick="hideWeather()">Close</button>
            </div>
        </div>

        <!-- Header -->
        <div class="header">
            <div style="width: 48px;"></div>
            <h1>Leslie Speech Assistant</h1>
            <button class="settings-btn" id="btnSettings">‚öôÔ∏è</button>
        </div>

        <!-- Home Page -->
        <div id="homePage" class="page active">
            <div class="home-page">
                <div class="welcome-text">
                    üëã Welcome to Leslie!<br><br>Choose what you'd like to do:
                </div>
                <button class="main-button btn-talking" id="btnStartTalking">
                    üé§ START TALKING
                </button>
                <button class="main-button btn-texting" id="btnStartTexting">
                    üìù START TEXTING
                </button>
                <button class="main-button btn-phone" id="btnPhoneCall">
                    üìû PHONE CALL
                </button>
                <button class="main-button btn-commands" id="btnCommands">
                    üó£Ô∏è LESLIE COMMANDS
                </button>
                <div class="tips-box">
                    üí° Tips:<br>
                    ‚Ä¢ Voice commands work automatically - just say "Hey Leslie" + command<br>
                    ‚Ä¢ Watch the green indicator (top-right) for voice command status<br>
                    ‚Ä¢ Click START TALKING for continuous speech recognition<br>
                    ‚Ä¢ Use Enhanced Recognition for better accuracy with unclear speech<br>
                    ‚Ä¢ Small swipe areas: bottom center, left/right sides for weather<br>
                    ‚Ä¢ Works best with clear speech or whispers
                </div>
            </div>
        </div>

        <!-- Speech Recognition Page -->
        <div id="speechPage" class="page">
            <div class="speech-page">
                <div class="page-header header-speech">
                    <h2>üé§ Speech Recognition</h2>
                    <button class="close-btn" id="btnCloseSpeech">&times;</button>
                </div>
                
                <div class="status-text" id="statusText">
                    Ready to listen - Click START TALKING to begin!
                </div>
                <div class="speech-display">
                    <div class="speech-header">
                        Speech Recognition - Your Phrases
                    </div>
                    <div class="speech-content">
                        <div class="speech-text" id="recognizedText">
                            Your speech will appear here...
                        </div>
                    </div>
                </div>
                <div class="enhanced-section" id="enhancedSection">
                    <div class="enhanced-header">
                        <div class="enhanced-title">üî¨ Enhanced Recognition (OpenAI Whisper)</div>
                        <div class="cost-info">~$0.006/minute</div>
                    </div>
                    <div class="enhanced-status" id="enhancedStatus">
                        Better accuracy for unclear speech, whispers, and speech variations
                    </div>
                    <button class="control-btn btn-enhanced" id="enhancedButton">
                        üî¨ START ENHANCED RECOGNITION
                    </button>
                </div>
                <div class="control-row">
                    <button class="control-btn btn-listen" id="listenButton">
                        START TALKING
                    </button>
                    <button class="icon-btn btn-clear" id="clearButton" title="Clear Text">
                        üóëÔ∏è
                    </button>
                </div>
            </div>
        </div>

        <!-- Phone Call Page -->
        <div id="phonePage" class="page">
            <div class="page-header header-phone">
                <h2>üìû Your Contacts</h2>
                <button class="close-btn" id="btnClosePhone">&times;</button>
            </div>
            <div class="contact-search-section">
                <div style="font-size: 14px; font-weight: bold; color: #669900; margin-bottom: 8px;">
                    üîç Search Your Contacts:
                </div>
                <input type="text" id="contactSearch" class="contact-search-input"
                       placeholder="Type contact name or phone..." oninput="filterContacts(this.value)">
            </div>
            
            <div class="contact-loading-section" id="contactLoadingSection">
                <p><strong>üì± GET YOUR REAL CONTACTS</strong></p>
                <p style="color: #333; margin: 10px 0; font-size: 16px;">Currently showing: <span style="color: #cc0000;">Demo Contacts Only</span></p>
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    Choose how to load YOUR real contacts from your phone:
                </p>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button onclick="loadAllContacts()" style="margin: 5px; padding: 16px 24px; background: #669900; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        üìû LOAD ALL CONTACTS
                    </button>
                    <button onclick="loadSelectedContacts()" style="margin: 5px; padding: 16px 24px; background: #0099cc; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        üìã SELECT SPECIFIC CONTACTS
                    </button>
                </div>
                <p style="margin-top: 12px; font-size: 12px; color: #666;">
                    <strong>üìû LOAD ALL:</strong> Opens contact picker with auto-selection attempt<br>
                    <strong>üìã SELECT:</strong> Opens contact picker for manual selection<br>
                    <strong>‚ö†Ô∏è Works on Chrome Android & Safari iOS only</strong>
                </p>
            </div>
            
            <div class="contact-list-container">
                <div style="font-size: 12px; color: #669900; margin-bottom: 8px; text-align: center;">
                    üì± Your contacts will appear here - Tap any contact to call
                </div>
                <div class="contacts-list" id="contactsList"></div>
            </div>
            <div class="phone-home-section">
                <button class="btn-home" id="btnPhoneHome">üè† HOME</button>
            </div>
        </div>

        <!-- Text Input Page -->
        <div id="textInputPage" class="page">
            <div class="text-input-page">
                <div class="page-header header-text">
                    <h2>üìù Text Input</h2>
                    <button class="close-btn" id="btnCloseText">&times;</button>
                </div>
                <div class="text-input-content" style="margin-top: 10px;">
                    <div class="speak-text-container" style="margin-top: 60px;">
                        <button class="speak-phrase-btn" id="speakTextBtn">
                            üîä SPEAK TEXT
                        </button>
                        <textarea class="text-input large-text-input" id="largeTextInputField"
                                  placeholder="Type your message here..." style="margin-top: 8px; padding-top: 50px;"></textarea>
                    </div>
                    <div style="padding: 16px; text-align: center; background-color: #f0f0f0; margin-top: 8px; position: fixed; bottom: 0; left: 0; right: 0; z-index: 999;">
                        <button class="btn-home" id="btnTextHome">üè† HOME</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Leslie Commands Page -->
        <div id="commandsPage" class="page">
            <div class="page-header header-commands">
                <h2>üó£Ô∏è Leslie Commands</h2>
                <button class="close-btn" id="btnCloseCommands">&times;</button>
            </div>
            <div style="padding: 16px; max-height: 70vh; overflow-y: auto; background: white; border-radius: 8px; margin: 8px;">
                <div style="font-size: 16px; line-height: 1.6; color: #333;">
                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #0099cc;">
                        <strong>üé§ Available Voice Commands</strong><br>
                        <span style="font-size: 14px; color: #666;">Watch for the green indicator (top-right) showing voice commands are active</span>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #28a745;">
                            <strong style="color: #28a745;">üß≠ Navigation Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            ‚Ä¢ "Hey Leslie, <strong>home</strong>" - Returns to home page<br>
                            ‚Ä¢ "Hey Leslie, <strong>start talking</strong>" - Speech recognition page<br>
                            ‚Ä¢ "Hey Leslie, <strong>start texting</strong>" - Text input page<br>
                            ‚Ä¢ "Hey Leslie, <strong>phone</strong>" - Phone contacts page<br>
                            ‚Ä¢ "Hey Leslie, <strong>settings</strong>" - Settings page<br>
                            ‚Ä¢ "Hey Leslie, <strong>help</strong>" - Shows this commands list<br>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #007bff;">
                            <strong style="color: #007bff;">üå§Ô∏è Weather Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            ‚Ä¢ "Hey Leslie, <strong>weather</strong>" - Shows current weather<br>
                            ‚Ä¢ "Hey Leslie, <strong>hourly</strong>" - Shows 24-hour forecast<br>
                            ‚Ä¢ "Hey Leslie, <strong>weekly</strong>" - Shows 7-day forecast<br>
                            ‚Ä¢ "Hey Leslie, <strong>7 day</strong>" - Shows 7-day forecast<br>
                            ‚Ä¢ "Hey Leslie, <strong>close</strong>" - Closes weather displays<br>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #6f42c1;">
                            <strong style="color: #6f42c1;">üéôÔ∏è Recognition Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            ‚Ä¢ "Hey Leslie, <strong>enhanced mode on</strong>" - Enables enhanced recognition<br>
                            ‚Ä¢ "Hey Leslie, <strong>enhanced mode off</strong>" - Disables enhanced recognition<br>
                            ‚Ä¢ "Hey Leslie, <strong>stop listening</strong>" - Stops speech recognition<br>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #dc3545;">
                            <strong style="color: #dc3545;">üîä Speech Settings Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            ‚Ä¢ "Hey Leslie, <strong>speak faster</strong>" - Increases speech speed<br>
                            ‚Ä¢ "Hey Leslie, <strong>speak slower</strong>" - Decreases speech speed<br>
                            ‚Ä¢ "Hey Leslie, <strong>pause more</strong>" - Increases pause between words<br>
                            ‚Ä¢ "Hey Leslie, <strong>pause less</strong>" - Decreases pause between words<br>
                            ‚Ä¢ "Hey Leslie, <strong>voice commands off</strong>" - Disables voice responses<br>
                            ‚Ä¢ "Hey Leslie, <strong>voice commands on</strong>" - Enables voice responses<br>
                        </div>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107;">
                        <strong style="color: #856404;">üí° Tips for Better Recognition</strong><br>
                        <div style="margin-top: 8px; font-size: 14px; color: #856404;">
                            ‚Ä¢ Speak clearly and at normal volume<br>
                            ‚Ä¢ Wait for the green indicator before speaking<br>
                            ‚Ä¢ Voice commands work from any page except speech recognition<br>
                            ‚Ä¢ Commands are processed quickly and continuously<br>
                        </div>
                    </div>
                </div>
            </div>
            <div style="padding: 16px; text-align: center;">
                <button class="btn-home" id="btnCommandsHome">üè† HOME</button>
            </div>
        </div>

        <!-- Settings Page -->
        <div id="settingsPage" class="page">
            <div class="page-header header-settings">
                <h2>‚öôÔ∏è Leslie Settings</h2>
                <button class="close-btn" id="btnCloseSettings">&times;</button>
            </div>
            <div style="max-height: 500px; overflow-y: auto; padding: 0 8px;">
                <div class="api-key-section">
                    <div class="settings-title">OpenAI API Key (for Enhanced Recognition)</div>
                    <div class="settings-description">
                        Enter your OpenAI API key to enable Enhanced Recognition mode.
                        Get yours at <a href="https://platform.openai.com/api-keys" target="_blank">platform.openai.com</a>
                    </div>
                    <input type="password" class="api-key-input" id="apiKeyInput" placeholder="sk-...">
                    <div style="font-size: 12px; margin-top: 4px; color: #666;">
                        Your API key is stored locally and never shared
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Recognition Mode</div>
                    <div class="settings-description">Choose your preferred speech recognition method</div>
                    <div class="switch">
                        <input type="checkbox" id="autoEnhancedSwitch">
                        <label for="autoEnhancedSwitch">Auto-suggest Enhanced Recognition when needed</label>
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Speech Playback Speed</div>
                    <div class="settings-description">How fast Leslie repeats your speech back to you</div>
                    <input type="range" class="slider" id="speechSpeedSlider" min="0.5" max="2" step="0.2" value="1.0">
                    <div class="setting-value" id="speechSpeedValue">Normal (1.0x)</div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Pause Between Words</div>
                    <div class="settings-description">How long to wait for you to continue speaking (helps with slower speech patterns)</div>
                    <input type="range" class="slider" id="pauseBetweenWordsSlider" min="0.5" max="5" step="0.5" value="0.5">
                    <div class="setting-value" id="pauseBetweenWordsValue">0.5 seconds</div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Enhanced Recognition Mode</div>
                    <div class="settings-description">Use OpenAI Whisper for better accuracy with unclear speech</div>
                    <div class="switch">
                        <input type="checkbox" id="enhancedModeSwitch">
                        <label for="enhancedModeSwitch">Enable Enhanced Mode by default</label>
                    </div>
                    <div class="setting-value" id="enhancedModeLabel">Enhanced Mode: OFF</div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Voice Command Speech</div>
                    <div class="settings-description">Whether Leslie should speak responses to voice commands</div>
                    <div class="switch">
                        <input type="checkbox" id="speakVoiceCommandsSwitch" checked>
                        <label for="speakVoiceCommandsSwitch">Enable Voice Command Speech</label>
                    </div>
                    <div class="setting-value" id="speakVoiceCommandsLabel">Voice Command Speech: ON</div>
                </div>
            </div>
            <button class="back-btn" id="btnSettingsHome">‚Üê Back</button>
        </div>
    </div>

    <script>
        // === GLOBAL VARIABLES ===
        let recognition = null;
        let voiceCommandRecognition = null;
        let isListening = false;
        let isVoiceCommandListening = false;
        let speechSynth = window.speechSynthesis;
        let currentPage = 'home';
        let pageHistory = ['home'];
        let contacts = [];
        let filteredContacts = [];
        let userLocation = null;
        let phraseHistory = [];
        let microphonePermissionGranted = false;
        let isInitialized = false;
        
        // FIXED: Global voice command initialization tracking
        let voiceCommandsInitialized = false;
        
        // Session timeout
        let sessionTimeoutId = null;
        let lastSpeechTime = null;
        const SESSION_TIMEOUT = 3 * 60 * 1000; // 3 minutes
        
        // Duplicate prevention
        let lastProcessedPhrase = '';
        let lastPhraseTime = 0;
        let lastVoiceCommand = '';
        let lastVoiceCommandTime = 0;
        const DUPLICATE_TIMEOUT = 5000;
        const COMMAND_TIMEOUT = 3000;
        let speechTimeoutId = null;
        let pendingPhrase = null;
        
        // Settings
        let settings = {
            speechSpeed: 1.0,
            speakVoiceCommands: true,
            autoEnhanced: true,
            apiKey: '',
            pauseBetweenWords: 0.5,
            enhancedMode: false
        };

        // === INITIALIZATION ===
        function initApp() {
            console.log('üöÄ Initializing Leslie Speech Assistant...');
            
            // Prevent multiple initializations
            if (isInitialized) {
                console.log('‚ö†Ô∏è App already initialized, skipping...');
                return;
            }
            
            try {
                loadSettings();
                setupEventHandlers();
                
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.error('‚ùå Speech recognition not supported');
                    updateStatus('‚ùå Speech recognition not supported in this browser');
                    return;
                }
                
                setupSpeechRecognition();
                initializeContacts();
                setupSwipeGestures();
                getUserLocation();
                updateEnhancedSectionVisibility();
                updateTextSpeakButton();
                clearTextInput();
                
                // Set initialized flag
                isInitialized = true;
                
                // Initialize voice commands with longer delay to ensure everything is ready
                setTimeout(() => {
                    if (isInitialized) {
                        initializeVoiceCommandsWithPermissions();
                    }
                }, 3000);
                
                console.log('‚úÖ Leslie Speech Assistant initialized successfully!');
                
            } catch (error) {
                console.error('‚ùå Error during initialization:', error);
                updateStatus('‚ùå Initialization error - please refresh page');
            }
        }

        function setupEventHandlers() {
            try {
                // Navigation - Use safer event binding
                const btnStartTalking = document.getElementById('btnStartTalking');
                const btnStartTexting = document.getElementById('btnStartTexting');
                const btnPhoneCall = document.getElementById('btnPhoneCall');
                const btnCommands = document.getElementById('btnCommands');
                const btnSettings = document.getElementById('btnSettings');
                
                if (btnStartTalking) btnStartTalking.addEventListener('click', startTalkingFromHome);
                if (btnStartTexting) btnStartTexting.addEventListener('click', () => showPage('textInput'));
                if (btnPhoneCall) btnPhoneCall.addEventListener('click', () => showPage('phone'));
                if (btnCommands) btnCommands.addEventListener('click', () => showPage('commands'));
                if (btnSettings) btnSettings.addEventListener('click', () => showPage('settings'));
                
                // Close buttons
                const closeBtns = [
                    {id: 'btnCloseSpeech', action: () => showPage('home')},
                    {id: 'btnClosePhone', action: () => showPage('home')},
                    {id: 'btnCloseCommands', action: () => showPage('home')},
                    {id: 'btnCloseText', action: () => showPage('home')},
                    {id: 'btnCloseSettings', action: () => showPage('home')}
                ];
                
                closeBtns.forEach(btn => {
                    const element = document.getElementById(btn.id);
                    if (element) element.addEventListener('click', btn.action);
                });
                
                // Speech controls
                const listenButton = document.getElementById('listenButton');
                const clearButton = document.getElementById('clearButton');
                const enhancedButton = document.getElementById('enhancedButton');
                
                if (listenButton) listenButton.addEventListener('click', toggleListening);
                if (clearButton) clearButton.addEventListener('click', clearSpeechText);
                if (enhancedButton) enhancedButton.addEventListener('click', startEnhancedRecognition);
                
                // Home buttons
                const homeBtns = [
                    'btnPhoneHome', 'btnTextHome', 'btnSettingsHome', 'btnCommandsHome'
                ];
                
                homeBtns.forEach(btnId => {
                    const element = document.getElementById(btnId);
                    if (element) element.addEventListener('click', () => showPage('home'));
                });
                
                // Text controls
                const speakTextBtn = document.getElementById('speakTextBtn');
                const textInputField = document.getElementById('largeTextInputField');
                
                if (speakTextBtn) speakTextBtn.addEventListener('click', speakTextInput);
                if (textInputField) textInputField.addEventListener('input', updateTextSpeakButton);
                
                // Settings
                const settingsElements = [
                    {id: 'apiKeyInput', event: 'change', handler: (e) => saveApiKey(e.target.value)},
                    {id: 'speechSpeedSlider', event: 'input', handler: (e) => updateSpeechSpeed(e.target.value)},
                    {id: 'pauseBetweenWordsSlider', event: 'input', handler: (e) => updatePauseBetweenWords(e.target.value)},
                    {id: 'speakVoiceCommandsSwitch', event: 'change', handler: (e) => updateVoiceCommandSetting(e.target.checked)},
                    {id: 'autoEnhancedSwitch', event: 'change', handler: (e) => updateAutoEnhanced(e.target.checked)},
                    {id: 'enhancedModeSwitch', event: 'change', handler: (e) => updateEnhancedMode(e.target.checked)}
                ];
                
                settingsElements.forEach(setting => {
                    const element = document.getElementById(setting.id);
                    if (element) element.addEventListener(setting.event, setting.handler);
                });
                
                console.log('‚úÖ Event handlers set up successfully');
                
            } catch (error) {
                console.error('‚ùå Error setting up event handlers:', error);
            }
        }

        function setupSpeechRecognition() {
            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                recognition.maxAlternatives = 1;

                recognition.onstart = function() {
                    isListening = true;
                    updateListenButton();
                    updateStatus(`üé§ Listening - Pause tolerance: ${settings.pauseBetweenWords}s between words`);
                    resetSessionTimeout();
                    console.log('üé§ Speech recognition started successfully');
                };

                recognition.onend = function() {
                    isListening = false;
                    const listenButton = document.getElementById('listenButton');
                    
                    // FIXED: Only auto-restart if we're supposed to be listening (not during speech playback)
                    if (currentPage === 'speech' && listenButton && listenButton.textContent === 'STOP LISTENING') {
                        // FIXED: Longer restart delay to prevent issues after idle periods
                        const restartDelay = Math.max((settings.pauseBetweenWords * 1000) + 1000, 2000);
                        console.log(`üîÑ Restarting recognition after ${restartDelay}ms delay`);
                        
                        setTimeout(() => {
                            if (currentPage === 'speech' && listenButton.textContent === 'STOP LISTENING' && !speechSynth.speaking) {
                                try {
                                    recognition.start();
                                    console.log('‚úÖ Recognition restarted successfully');
                                } catch (e) {
                                    console.error('Failed to restart recognition:', e);
                                    updateListenButton();
                                    updateStatus('‚ùå Click "START TALKING" to restart');
                                }
                            }
                        }, restartDelay);
                    } else {
                        updateListenButton();
                        updateStatus('‚úÖ Stopped - Click "START TALKING" to restart');
                    }
                };

                recognition.onerror = function(event) {
                    console.error('üé§ Recognition error:', event.error);
                    isListening = false;
                    updateListenButton();
                    
                    if (event.error === 'not-allowed') {
                        updateStatus('‚ùå Microphone permission denied');
                        microphonePermissionGranted = false;
                        return;
                    }
                    
                    updateStatus('‚ùå Error: ' + event.error);
                    
                    if (event.error !== 'not-allowed' && currentPage === 'speech') {
                        // FIXED: Apply pause between words setting to restart delay after error
                        const restartDelay = Math.max((settings.pauseBetweenWords * 1000) + 1500, 2000);
                        setTimeout(() => {
                            if (currentPage === 'speech' && !isListening) {
                                console.log('üîÑ Auto-restarting after error with longer delay');
                                try {
                                    recognition.start();
                                    updateStatus('üîÑ Restarted after error');
                                } catch (e) {
                                    updateStatus('‚ùå Could not restart - click START TALKING');
                                }
                            }
                        }, restartDelay);
                    }
                };

                recognition.onresult = function(event) {
                    lastSpeechTime = Date.now();
                    resetSessionTimeout();
                    
                    // FIXED: Only process the most recent final result to prevent cascading
                    let latestFinalResult = null;
                    let interimText = '';
                    
                    // Find the most recent final result
                    for (let i = event.results.length - 1; i >= 0; i--) {
                        if (event.results[i].isFinal) {
                            latestFinalResult = event.results[i][0].transcript.trim();
                            break;
                        }
                    }
                    
                    // Show interim results for feedback
                    for (let i = 0; i < event.results.length; i++) {
                        if (!event.results[i].isFinal) {
                            interimText += event.results[i][0].transcript;
                        }
                    }
                    
                    if (interimText.trim()) {
                        updateStatus(`üé§ Hearing: "${interimText.trim()}"`);
                    }
                    
                    // FIXED: Only process if we have a new final result and it's different from last
                    if (latestFinalResult && latestFinalResult.length > 1) {
                        const now = Date.now();
                        const isDifferent = latestFinalResult !== lastProcessedPhrase;
                        const enoughTimePassed = (now - lastPhraseTime) > 1000; // 1 second gap
                        
                        if (isDifferent || enoughTimePassed) {
                            console.log('üé§ NEW FINAL RESULT ONLY:', `"${latestFinalResult}"`);
                            lastProcessedPhrase = latestFinalResult;
                            lastPhraseTime = now;
                            processFinalSpeech(latestFinalResult);
                        } else {
                            console.log('üö´ Ignoring duplicate/recent phrase:', latestFinalResult);
                        }
                    }
                };
                
                console.log('‚úÖ Speech recognition set up successfully');
                
            } catch (error) {
                console.error('‚ùå Error setting up speech recognition:', error);
            }
        }

        function processFinalSpeech(text) {
            if (!text || text.length <= 1) return;
            
            console.log('üéôÔ∏è PROCESSING FINAL SPEECH:', `"${text}"`);
            
            // FIXED: Better Leslie command detection that prevents ANY display
            const lowerText = text.toLowerCase().trim();
            
            // Check if it starts with or contains Leslie command patterns
            const isLeslieCommand = lowerText.startsWith('hey leslie') || 
                                  lowerText.startsWith('leslie ') ||
                                  lowerText.startsWith('less lee') ||
                                  lowerText.startsWith('lesley ') ||
                                  lowerText.includes('hey leslie') ||
                                  lowerText === 'leslie' ||
                                  lowerText === 'hey leslie' ||
                                  lowerText === 'hey';
            
            if (isLeslieCommand) {
                console.log('üéØ LESLIE COMMAND DETECTED - BLOCKING FROM DISPLAY');
                
                if (currentPage === 'speech') {
                    // FIXED: Completely block from display on speech page
                    console.log('üö´ BLOCKING LESLIE COMMAND FROM SPEECH PAGE DISPLAY');
                    updateStatus('üé§ Voice command processed - ready for next phrase');
                    
                    // Process as voice command silently
                    setTimeout(() => {
                        processVoiceCommand(text);
                    }, 50);
                    
                    // FIXED: Clear the display immediately to prevent any "Hey" showing
                    setTimeout(() => {
                        updateSpeechDisplaySingle(''); // Clear display
                        updateStatus('üé§ Ready for next phrase');
                    }, 100);
                    
                    return; // CRITICAL: Exit early to prevent any processing as regular speech
                } else {
                    // On other pages, process as voice command
                    processVoiceCommand(text);
                    return;
                }
            }
            
            // FIXED: Only process as regular speech if it's absolutely NOT a Leslie command
            console.log('‚úÖ CONFIRMED REGULAR SPEECH - PROCESSING:', text);
            processCompletePhrase(text);
        }
        
        function processCompletePhrase(text) {
            console.log('üéôÔ∏è PROCESSING COMPLETE PHRASE FOR DISPLAY AND SPEECH:', text);
            
            // FIXED: Display the complete phrase immediately
            updateSpeechDisplaySingle(text);
            updateStatus(`‚úÖ Captured: "${text}" - Now speaking...`);
            
            // FIXED: Force speech synthesis immediately
            console.log('üîä FORCING SPEECH SYNTHESIS FOR:', text);
            forceSpeakPhrase(text);
        }

        // === VOICE COMMANDS ===
        async function initializeVoiceCommandsWithPermissions() {
            // FIXED: Only initialize once globally
            if (voiceCommandsInitialized) {
                console.log('‚úÖ Voice commands already initialized globally - skipping');
                return;
            }

            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                console.log('‚ùå Speech recognition not supported');
                updateVoiceCommandStatus('not-supported');
                return;
            }

            try {
                updateVoiceCommandStatus('requesting-permission');
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphonePermissionGranted = true;
                stream.getTracks().forEach(track => track.stop());
                console.log('‚úÖ Microphone permission granted');
                
                initializeVoiceCommands();
                voiceCommandsInitialized = true; // FIXED: Mark as initialized
                
            } catch (error) {
                console.log('‚ùå Microphone permission denied:', error.message);
                microphonePermissionGranted = false;
                updateVoiceCommandStatus('permission-denied');
            }
        }

        function initializeVoiceCommands() {
            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                voiceCommandRecognition = new SpeechRecognition();
                
                voiceCommandRecognition.continuous = true;
                voiceCommandRecognition.interimResults = false;
                voiceCommandRecognition.lang = 'en-US';
                voiceCommandRecognition.maxAlternatives = 1;
                
                voiceCommandRecognition.onstart = function() {
                    isVoiceCommandListening = true;
                    updateVoiceCommandStatus('active');
                    console.log('‚úÖ Voice commands started');
                };
                
                voiceCommandRecognition.onresult = function(event) {
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        if (event.results[i].isFinal) {
                            const transcript = event.results[i][0].transcript.trim();
                            console.log(`üéôÔ∏è Voice command candidate: "${transcript}"`);
                            
                            const lowerTranscript = transcript.toLowerCase();
                            // FIXED: More comprehensive Leslie detection
                            const leslieDetected = lowerTranscript.includes('leslie') || 
                                                 lowerTranscript.includes('hey leslie') ||
                                                 lowerTranscript.includes('less lee') ||
                                                 lowerTranscript.includes('lesley') ||
                                                 lowerTranscript.includes('wesley') ||
                                                 lowerTranscript.includes('bessie');
                            
                            if (leslieDetected) {
                                console.log('üéØ Leslie command detected - processing immediately');
                                // FIXED: Process immediately without delay
                                processVoiceCommand(transcript);
                            }
                        }
                    }
                };
                
                voiceCommandRecognition.onend = function() {
                    isVoiceCommandListening = false;
                    updateVoiceCommandStatus('ready');
                    console.log('üéôÔ∏è Voice command session ended');
                    
                    // FIXED: Only restart if not on speech page and speech recognition isn't running
                    if (microphonePermissionGranted && isInitialized && !isListening) {
                        setTimeout(() => {
                            if (!isVoiceCommandListening && !isListening) {
                                startVoiceCommands();
                            }
                        }, 500); // FIXED: Longer delay to prevent conflicts
                    }
                };
                
                voiceCommandRecognition.onerror = function(event) {
                    isVoiceCommandListening = false;
                    console.log('üéôÔ∏è Voice command error:', event.error);
                    
                    if (event.error === 'not-allowed') {
                        microphonePermissionGranted = false;
                        updateVoiceCommandStatus('permission-denied');
                        return;
                    }
                    
                    updateVoiceCommandStatus('ready');
                    
                    // FIXED: Only restart if conditions are right
                    if (microphonePermissionGranted && isInitialized && !isListening) {
                        setTimeout(() => {
                            if (!isVoiceCommandListening && !isListening) {
                                startVoiceCommands();
                            }
                        }, 1000); // FIXED: Longer delay after errors
                    }
                };
                
                // FIXED: Only start voice commands if speech recognition isn't running
                if (!isListening) {
                    startVoiceCommands();
                }
                console.log('‚úÖ Voice commands initialized successfully');
                
            } catch (error) {
                console.error('‚ùå Error initializing voice commands:', error);
            }
        }

        function startVoiceCommands() {
            // FIXED: Don't start if speech recognition is running to prevent conflicts
            if (isListening || isVoiceCommandListening || !microphonePermissionGranted || !isInitialized) {
                console.log('üö´ Skipping voice commands - conditions not met');
                return;
            }
            
            if (!voiceCommandRecognition) return;
            
            try {
                console.log('üéôÔ∏è Starting voice commands...');
                voiceCommandRecognition.start();
                voiceCommandAttempts = 0;
            } catch (e) {
                console.log('üéôÔ∏è Error starting voice commands:', e.message);
                if (microphonePermissionGranted && isInitialized) {
                    setTimeout(() => {
                        startVoiceCommands();
                    }, 1000);
                }
            }
        }

        function stopVoiceCommands() {
            if (voiceCommandRecognition && isVoiceCommandListening) {
                try {
                    voiceCommandRecognition.abort();
                    console.log('üõë Voice commands stopped successfully');
                } catch (e) {
                    console.log('üéôÔ∏è Error stopping voice commands:', e);
                }
            }
            
            isVoiceCommandListening = false;
            updateVoiceCommandStatus('ready');
            
            if (voiceCommandRestartTimeout) {
                clearTimeout(voiceCommandRestartTimeout);
                voiceCommandRestartTimeout = null;
            }
        }

        function updateVoiceCommandStatus(status) {
            const statusEl = document.getElementById('voiceCommandStatus');
            if (!statusEl) return;
            
            statusEl.classList.remove('active', 'permission-needed');
            
            switch (status) {
                case 'active':
                    statusEl.classList.add('active');
                    statusEl.textContent = 'üéôÔ∏è Voice Commands Active';
                    break;
                case 'ready':
                    statusEl.textContent = 'üéôÔ∏è Voice Commands Ready';
                    statusEl.style.display = 'none';
                    break;
                case 'requesting-permission':
                    statusEl.classList.add('permission-needed');
                    statusEl.textContent = 'üé§ Requesting Microphone...';
                    break;
                case 'permission-denied':
                    statusEl.classList.add('permission-needed');
                    statusEl.textContent = '‚ùå Mic Permission Needed';
                    break;
                case 'not-supported':
                    statusEl.classList.add('permission-needed');
                    statusEl.textContent = '‚ùå Not Supported';
                    break;
                default:
                    statusEl.textContent = 'üéôÔ∏è Voice Commands Ready';
                    statusEl.style.display = 'none';
            }
        }

        function processVoiceCommand(command) {
            const cmd = command.toLowerCase().trim();
            const now = Date.now();
            
            console.log('üéØ VOICE COMMAND RECEIVED:', cmd);
            
            // FIXED: Ultra-short duplicate prevention for maximum responsiveness
            if (cmd === lastVoiceCommand && (now - lastVoiceCommandTime) < 50) {
                console.log('üö´ Duplicate voice command ignored (50ms window)');
                return;
            }
            
            lastVoiceCommand = cmd;
            lastVoiceCommandTime = now;
            
            // FIXED: Execute immediately with no delays
            executeVoiceCommand(cmd);
        }

        function executeVoiceCommand(cmd) {
            console.log('‚ö° Executing command:', cmd);
            
            const weatherDisplay = document.getElementById('weatherDisplay');
            const isWeatherOpen = weatherDisplay && !weatherDisplay.classList.contains('hidden');
            
            let commandExecuted = false;
            
            // Navigation commands - FIXED: More variations for better recognition
            if ((cmd.includes('home') && !cmd.includes('phone')) || cmd === 'hey leslie home' || cmd.includes('go home')) {
                if (isWeatherOpen) hideWeather();
                showPage('home');
                speakResponse('Going home');
                commandExecuted = true;
            } else if (cmd.includes('start talking') || (cmd.includes('talking') && !cmd.includes('stop')) || cmd.includes('speech recognition')) {
                if (isWeatherOpen) hideWeather();
                startTalkingFromHome();
                speakResponse('Starting speech recognition');
                commandExecuted = true;
            } else if (cmd.includes('start texting') || (cmd.includes('texting') && !cmd.includes('stop')) || cmd.includes('text input')) {
                if (isWeatherOpen) hideWeather();
                showPage('textInput');
                speakResponse('Opening text input');
                commandExecuted = true;
            } else if (cmd.includes('phone') || cmd.includes('contacts') || cmd.includes('call')) {
                if (isWeatherOpen) hideWeather();
                showPage('phone');
                speakResponse('Opening phone contacts');
                commandExecuted = true;
            } else if (cmd.includes('settings') || cmd.includes('setting')) {
                if (isWeatherOpen) hideWeather();
                showPage('settings');
                speakResponse('Opening settings');
                commandExecuted = true;
            } else if (cmd.includes('help') || (cmd.includes('commands') && !cmd.includes('voice commands'))) {
                if (isWeatherOpen) hideWeather();
                showPage('commands');
                speakResponse('Showing commands');
                commandExecuted = true;
            } else if (cmd.includes('close') || cmd.includes('clothes') || cmd.includes('closed') || cmd.includes('hide weather') || cmd.includes('hide') || cmd.includes('dismiss')) {
                if (isWeatherOpen) {
                    hideWeather();
                    speakResponse('Weather closed');
                    commandExecuted = true;
                } else if (currentPage !== 'home') {
                    showPage('home');
                    speakResponse('Going home');
                    commandExecuted = true;
                } else {
                    speakResponse('Nothing to close');
                    commandExecuted = true;
                }
            } else if (cmd.includes('stop listening') || cmd.includes('stop')) {
                if (isListening) {
                    toggleListening();
                    speakResponse('Stopping speech recognition');
                    commandExecuted = true;
                }
            }
            // Weather commands - FIXED: More variations
            else if (cmd.includes('weather') || cmd.includes('current weather') || cmd.includes('what\'s the weather')) {
                showCurrentWeather();
                speakResponse('Showing current weather');
                commandExecuted = true;
            } else if (cmd.includes('hourly') || cmd.includes('hour') || cmd.includes('24 hour') || cmd.includes('24 hours')) {
                showHourlyWeather();
                speakResponse('Showing hourly forecast');
                commandExecuted = true;
            } else if (cmd.includes('weekly') || cmd.includes('7 day') || cmd.includes('seven day') || cmd.includes('week') || cmd.includes('7day') || cmd.includes('7-day')) {
                showWeeklyWeather();
                speakResponse('Showing 7 day forecast');
                commandExecuted = true;
            }
            // Enhanced Recognition Commands - FIXED: More variations
            else if (cmd.includes('enhanced mode on') || cmd.includes('enhanced on') || cmd.includes('enable enhanced')) {
                settings.enhancedMode = true;
                updateEnhancedMode(true);
                speakResponse('Enhanced recognition mode enabled');
                commandExecuted = true;
            } else if (cmd.includes('enhanced mode off') || cmd.includes('enhanced off') || cmd.includes('disable enhanced')) {
                settings.enhancedMode = false;
                updateEnhancedMode(false);
                speakResponse('Enhanced recognition mode disabled');
                commandExecuted = true;
            }
            // Speech Settings Commands - FIXED: Added "speak less" and fixed command matching
            else if (cmd.includes('speak faster') || cmd.includes('faster speech') || cmd.includes('speed up') || cmd.includes('talk faster')) {
                const currentSpeed = parseFloat(settings.speechSpeed) || 1.0;
                const newSpeed = Math.min(parseFloat((currentSpeed + 0.2).toFixed(1)), 2.0);
                updateSpeechSpeed(newSpeed);
                speakResponse(`Speech speed increased to ${newSpeed}`);
                commandExecuted = true;
            } else if (cmd.includes('speak slower') || cmd.includes('slower speech') || cmd.includes('slow down') || cmd.includes('talk slower') || cmd.includes('speak less')) {
                const currentSpeed = parseFloat(settings.speechSpeed) || 1.0;
                const newSpeed = Math.max(parseFloat((currentSpeed - 0.2).toFixed(1)), 0.5);
                updateSpeechSpeed(newSpeed);
                speakResponse(`Speech speed decreased to ${newSpeed}`);
                commandExecuted = true;
            } else if (cmd.includes('pause more') || cmd.includes('longer pause') || cmd.includes('more pause') || cmd.includes('wait longer')) {
                const currentPause = parseFloat(settings.pauseBetweenWords) || 0.5;
                const newPause = Math.min(parseFloat((currentPause + 0.5).toFixed(1)), 5.0);
                updatePauseBetweenWords(newPause);
                speakResponse(`Pause between words increased to ${newPause} seconds`);
                commandExecuted = true;
            } else if (cmd.includes('pause less') || cmd.includes('shorter pause') || cmd.includes('less pause') || cmd.includes('wait less')) {
                const currentPause = parseFloat(settings.pauseBetweenWords) || 0.5;
                const newPause = Math.max(parseFloat((currentPause - 0.5).toFixed(1)), 0.5);
                updatePauseBetweenWords(newPause);
                speakResponse(`Pause between words decreased to ${newPause} seconds`);
                commandExecuted = true;
            } else if (cmd.includes('voice command off') || cmd.includes('voice commands off') || cmd.includes('disable voice command') || cmd.includes('turn off voice command')) {
                settings.speakVoiceCommands = false;
                updateVoiceCommandSetting(false);
                // Don't speak response since they just turned off voice responses
                commandExecuted = true;
            } else if (cmd.includes('voice command on') || cmd.includes('voice commands on') || cmd.includes('enable voice command') || cmd.includes('turn on voice command')) {
                settings.speakVoiceCommands = true;
                updateVoiceCommandSetting(true);
                speakResponse('Voice command speech enabled');
                commandExecuted = true;
            }
            
            if (!commandExecuted) {
                console.log('‚ùå Command not recognized:', cmd);
                speakResponse('Command not recognized');
            } else {
                console.log('‚úÖ Command executed successfully:', cmd);
            }
        }

        function speakResponse(text) {
            if (!settings.speakVoiceCommands) return;
            
            console.log('üîä VOICE COMMAND RESPONSE - SPEAKING:', text);
            
            // FIXED: Don't interfere with speech synthesis for voice commands
            // Use a separate, simpler approach
            setTimeout(() => {
                try {
                    // Don't cancel existing speech - let it finish
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = settings.speechSpeed || 1.0;
                    utterance.pitch = 1.1; // Slightly different pitch for voice commands
                    utterance.volume = 0.9; // Slightly lower volume
                    
                    utterance.onstart = function() {
                        console.log('‚úÖ Voice command response started:', text);
                    };
                    
                    utterance.onend = function() {
                        console.log('‚úÖ Voice command response completed:', text);
                    };
                    
                    utterance.onerror = function(event) {
                        console.log('‚ö†Ô∏è Voice command speech error:', event.error);
                        // Don't show error for voice command speech failures
                    };
                    
                    if (speechSynth.paused) {
                        speechSynth.resume();
                    }
                    
                    // FIXED: Queue the voice command speech instead of interrupting
                    speechSynth.speak(utterance);
                    
                } catch (error) {
                    console.error('‚ùå Voice command speech error:', error);
                    // Silently fail for voice command speech
                }
            }, 100);
        }

        async function forceSpeakPhrase(text) {
            console.log('üîä FORCE SPEAK PHRASE - REQUESTING AUDIO PERMISSION:', text);
            
            try {
                // FIXED: Request audio permissions first
                console.log('üé§ Requesting audio permissions for speech...');
                
                // Try to get audio permission through getUserMedia
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    stream.getTracks().forEach(track => track.stop()); // Stop immediately, we just needed permission
                    console.log('‚úÖ Audio permission granted for speech');
                } catch (permissionError) {
                    console.log('‚ö†Ô∏è Could not get audio permission:', permissionError.message);
                    updateStatus('‚ùå Audio permission needed - please allow microphone access');
                    return;
                }
                
                // FIXED: User interaction required - create click interaction first
                console.log('üñ±Ô∏è Creating user interaction for speech...');
                
                // Create a temporary button to get user interaction
                const interactionBtn = document.createElement('button');
                interactionBtn.style.position = 'fixed';
                interactionBtn.style.top = '10px';
                interactionBtn.style.right = '10px';
                interactionBtn.style.zIndex = '99999';
                interactionBtn.style.padding = '10px 15px';
                interactionBtn.style.backgroundColor = '#0099cc';
                interactionBtn.style.color = 'white';
                interactionBtn.style.border = 'none';
                interactionBtn.style.borderRadius = '5px';
                interactionBtn.style.cursor = 'pointer';
                interactionBtn.textContent = `üîä Click to Speak: "${text}"`;
                
                document.body.appendChild(interactionBtn);
                
                interactionBtn.onclick = function() {
                    console.log('‚úÖ User clicked - now attempting speech');
                    document.body.removeChild(interactionBtn);
                    
                    // Now try speech synthesis with user interaction
                    attemptSpeechSynthesis(text);
                };
                
                // Auto-click after a short delay to try automatic speech
                setTimeout(() => {
                    console.log('ü§ñ Auto-clicking for automatic speech attempt');
                    if (document.body.contains(interactionBtn)) {
                        interactionBtn.click();
                    }
                }, 500);
                
                // Remove button after 10 seconds if user doesn't click
                setTimeout(() => {
                    if (document.body.contains(interactionBtn)) {
                        document.body.removeChild(interactionBtn);
                        updateStatus('‚ùå Speech timed out - click button faster next time');
                    }
                }, 10000);
                
            } catch (error) {
                console.error('‚ùå FORCE SPEAK SETUP ERROR:', error);
                updateStatus('‚ùå Speech setup failed - check browser audio settings');
            }
        }
        
        function attemptSpeechSynthesis(text) {
            console.log('üé§ ATTEMPTING SPEECH SYNTHESIS WITH USER INTERACTION:', text);
            
            try {
                // Cancel any existing speech
                speechSynth.cancel();
                
                setTimeout(() => {
                    if (speechSynth.speaking) speechSynth.cancel();
                    
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = parseFloat(settings.speechSpeed) || 1.0;
                    utterance.pitch = 1.0;
                    utterance.volume = 1.0;
                    utterance.lang = 'en-US';
                    
                    let speechStarted = false;
                    
                    utterance.onstart = function() {
                        speechStarted = true;
                        console.log('‚úÖ SPEECH STARTED WITH USER INTERACTION:', text);
                        updateStatus(`üîä Speaking: "${text}"`);
                    };
                    
                    utterance.onend = function() {
                        console.log('‚úÖ SPEECH COMPLETED:', text);
                        updateStatus('üé§ Ready for next phrase');
                    };
                    
                    utterance.onerror = function(event) {
                        console.error('‚ùå SPEECH ERROR EVEN WITH INTERACTION:', event.error);
                        updateStatus(`‚ùå Speech error: ${event.error} - Check device volume and audio settings`);
                    };
                    
                    // Ensure speech synthesis is ready
                    if (speechSynth.paused) speechSynth.resume();
                    
                    console.log('üé§ SPEAKING WITH USER INTERACTION:', text);
                    speechSynth.speak(utterance);
                    
                    // Backup attempt
                    setTimeout(() => {
                        if (!speechStarted && !speechSynth.speaking) {
                            console.log('üîÑ BACKUP SPEECH ATTEMPT WITH INTERACTION');
                            const backupUtterance = new SpeechSynthesisUtterance(text);
                            backupUtterance.rate = 1.0;
                            backupUtterance.volume = 1.0;
                            speechSynth.speak(backupUtterance);
                        }
                    }, 1000);
                    
                }, 100);
                
            } catch (error) {
                console.error('‚ùå SPEECH SYNTHESIS ERROR:', error);
                updateStatus('‚ùå Speech synthesis failed - browser may not support speech');
            }
        }

        function speakTextInput() {
            const textInput = document.getElementById('largeTextInputField');
            if (!textInput) return;
            
            const text = textInput.value.trim();
            if (text) {
                speechSynth.cancel();
                setTimeout(() => {
                    try {
                        const utterance = new SpeechSynthesisUtterance(text);
                        utterance.rate = settings.speechSpeed;
                        utterance.pitch = 1.0;
                        utterance.volume = 1.0;
                        
                        utterance.onend = function() {
                            textInput.value = '';
                            updateTextSpeakButton();
                        };
                        
                        speechSynth.speak(utterance);
                    } catch (error) {
                        console.error('‚ùå Error speaking text input:', error);
                    }
                }, 200);
            }
        }

        // === UI FUNCTIONS ===
        function showPage(pageId, addToHistory = true) {
            console.log('üìÑ Showing page:', pageId);
            
            try {
                // Hide all pages
                document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
                
                // Show target page
                const targetPage = document.getElementById(pageId + 'Page');
                if (targetPage) {
                    targetPage.classList.add('active');
                    currentPage = pageId;
                    
                    if (addToHistory) {
                        pageHistory.push(pageId);
                    }
                    
                    // Handle speech page transitions
                    if (pageId !== 'speech') {
                        clearSessionTimeout();
                        if (isListening && recognition) {
                            try {
                                recognition.abort();
                            } catch (e) {
                                console.log('Error stopping recognition:', e);
                            }
                            isListening = false;
                        }
                    }
                    
                    if (pageId === 'speech') {
                        stopVoiceCommands();
                        clearSpeechText();
                        
                        if (recognition) {
                            try {
                                recognition.abort();
                            } catch (e) {
                                console.log('Error aborting recognition:', e);
                            }
                            isListening = false;
                        }
                        
                        setTimeout(() => {
                            if (currentPage === 'speech') {
                                const listenButton = document.getElementById('listenButton');
                                if (listenButton) {
                                    listenButton.textContent = 'STOP LISTENING';
                                    listenButton.className = 'control-btn btn-stop';
                                }
                                updateStatus('üé§ Starting in 1 second...');
                                
                                setTimeout(() => {
                                    if (currentPage === 'speech') {
                                        updateStatus('üé§ Listening - Speak clearly');
                                        startListening();
                                    }
                                }, 1000);
                            }
                        }, 200);
                    } else {
                        // FIXED: Only start voice commands if not already initialized
                        if (microphonePermissionGranted && isInitialized && !voiceCommandsInitialized && !isListening) {
                            console.log('üéôÔ∏è Starting voice commands for first time');
                            setTimeout(() => {
                                initializeVoiceCommandsWithPermissions();
                            }, 300);
                        } else if (voiceCommandsInitialized && !isVoiceCommandListening && !isListening) {
                            console.log('üéôÔ∏è Restarting existing voice commands');
                            setTimeout(() => {
                                startVoiceCommands();
                            }, 300);
                        }
                    }
                    
                    if (pageId === 'phone') {
                        displayContactsOnPhonePage();
                    }
                    
                    if (pageId === 'textInput') {
                        console.log('üì± TEXTING PAGE - NUCLEAR KEYBOARD DEPLOYMENT');
                        
                        // FIXED: Immediate nuclear option - no delays
                        forceKeyboardNuclearOption();
                        
                        // Also try standard methods as backup
                        setTimeout(() => forceKeyboardOpen(), 100);
                        setTimeout(() => forceKeyboardOpen(), 500);
                        setTimeout(() => forceKeyboardOpen(), 1000);
                        setTimeout(() => forceKeyboardOpen(), 1500);
                        setTimeout(() => forceKeyboardOpen(), 2000);
                        setTimeout(() => forceKeyboardOpen(), 3000);
                    }
                }
            } catch (error) {
                console.error('‚ùå Error showing page:', error);
            }
        }
        
        function forceKeyboardOpen() {
            const textInput = document.getElementById('largeTextInputField');
            if (!textInput) return;
            
            console.log('üì± ULTRA AGGRESSIVE KEYBOARD FORCING - MAXIMUM EFFORT...');
            
            // FIXED: Remove all potential blocking attributes
            textInput.removeAttribute('readonly');
            textInput.removeAttribute('disabled');
            textInput.style.pointerEvents = 'auto';
            textInput.style.userSelect = 'text';
            textInput.style.webkitUserSelect = 'text';
            textInput.style.touchAction = 'manipulation';
            textInput.setAttribute('contenteditable', 'true');
            
            // Method 1: Immediate aggressive focus
            textInput.focus();
            textInput.click();
            textInput.select();
            
            // Method 2: Create fake user interaction
            const clickEvent = new MouseEvent('click', {
                view: window,
                bubbles: true,
                cancelable: true,
                clientX: textInput.offsetLeft + 10,
                clientY: textInput.offsetTop + 10
            });
            textInput.dispatchEvent(clickEvent);
            
            // Method 3: Force input event with value change
            const originalValue = textInput.value;
            textInput.value = originalValue + '‚ñà'; // Special character to force keyboard
            textInput.focus();
            
            const inputEvent = new InputEvent('input', {
                bubbles: true,
                cancelable: true,
                data: '‚ñà',
                inputType: 'insertText'
            });
            textInput.dispatchEvent(inputEvent);
            
            // Method 4: Position cursor at end
            setTimeout(() => {
                textInput.value = originalValue; // Restore value
                textInput.focus();
                textInput.setSelectionRange(textInput.value.length, textInput.value.length);
                textInput.scrollTop = textInput.scrollHeight;
            }, 10);
            
            // Method 5: iOS Safari nuclear option
            if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                setTimeout(() => {
                    // Create temporary visible input to steal focus
                    const tempInput = document.createElement('input');
                    tempInput.type = 'text';
                    tempInput.style.position = 'fixed';
                    tempInput.style.top = '50%';
                    tempInput.style.left = '50%';
                    tempInput.style.zIndex = '9999';
                    tempInput.style.opacity = '0.01'; // Nearly invisible but not hidden
                    tempInput.style.width = '1px';
                    tempInput.style.height = '1px';
                    tempInput.setAttribute('inputmode', 'text');
                    
                    document.body.appendChild(tempInput);
                    tempInput.focus();
                    tempInput.click();
                    
                    setTimeout(() => {
                        textInput.focus();
                        textInput.click();
                        textInput.select();
                        document.body.removeChild(tempInput);
                    }, 200);
                }, 100);
                
                // Multiple aggressive attempts for iOS
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        textInput.focus();
                        textInput.click();
                        textInput.select();
                        
                        // Simulate touch for iOS
                        const touchStartEvent = new TouchEvent('touchstart', {
                            bubbles: true,
                            cancelable: true,
                            touches: [{
                                identifier: 0,
                                target: textInput,
                                clientX: textInput.offsetLeft + textInput.offsetWidth / 2,
                                clientY: textInput.offsetTop + textInput.offsetHeight / 2,
                                pageX: textInput.offsetLeft + textInput.offsetWidth / 2,
                                pageY: textInput.offsetTop + textInput.offsetHeight / 2,
                                screenX: textInput.offsetLeft + textInput.offsetWidth / 2,
                                screenY: textInput.offsetTop + textInput.offsetHeight / 2
                            }]
                        });
                        
                        textInput.dispatchEvent(touchStartEvent);
                        
                        setTimeout(() => {
                            const touchEndEvent = new TouchEvent('touchend', {
                                bubbles: true,
                                cancelable: true,
                                changedTouches: [{
                                    identifier: 0,
                                    target: textInput,
                                    clientX: textInput.offsetLeft + textInput.offsetWidth / 2,
                                    clientY: textInput.offsetTop + textInput.offsetHeight / 2
                                }]
                            });
                            textInput.dispatchEvent(touchEndEvent);
                        }, 50);
                        
                    }, 100 + (i * 200));
                }
            }
            
            // Method 6: Android Chrome nuclear option
            if (/Android/.test(navigator.userAgent)) {
                setTimeout(() => {
                    // Viewport manipulation for Android
                    const viewport = document.querySelector('meta[name=viewport]');
                    const originalViewport = viewport ? viewport.content : '';
                    
                    if (viewport) {
                        viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=10.0, user-scalable=yes';
                    }
                    
                    // Scroll element into perfect view
                    textInput.scrollIntoView({ 
                        behavior: 'instant', 
                        block: 'center',
                        inline: 'center'
                    });
                    
                    // Multiple focus attempts
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            textInput.focus();
                            textInput.click();
                            textInput.select();
                        }, i * 100);
                    }
                    
                    // Restore viewport after delay
                    setTimeout(() => {
                        if (viewport && originalViewport) {
                            viewport.content = originalViewport;
                        }
                    }, 2000);
                    
                }, 200);
            }
            
            // Method 7: Universal fallback attempts
            const fallbackAttempts = [500, 1000, 1500, 2000, 2500, 3000];
            fallbackAttempts.forEach((delay, index) => {
                setTimeout(() => {
                    console.log(`üì± Fallback keyboard attempt ${index + 1}`);
                    textInput.focus();
                    textInput.click();
                    textInput.select();
                    textInput.setSelectionRange(textInput.value.length, textInput.value.length);
                }, delay);
            });
        }

        function startTalkingFromHome() {
            console.log('üé§ Starting talking from home');
            showPage('speech');
            setTimeout(() => {
                if (!isListening && currentPage === 'speech') {
                    startListening();
                }
            }, 100);
        }

        function toggleListening() {
            if (isListening || document.getElementById('listenButton')?.textContent === 'STOP LISTENING') {
                clearSessionTimeout();
                if (recognition && isListening) {
                    try {
                        recognition.abort();
                    } catch (error) {
                        console.log('Error aborting recognition:', error);
                    }
                }
                isListening = false;
                updateListenButton();
                updateStatus('üõë Stopped listening. Click "START TALKING" to restart.');
                
                // FIXED: Start voice commands after stopping speech recognition
                setTimeout(() => {
                    if (!isListening && microphonePermissionGranted && isInitialized) {
                        startVoiceCommands();
                    }
                }, 1000);
            } else {
                lastSpeechTime = Date.now();
                startListening();
            }
        }

        function startListening() {
            if (!recognition) return;
            
            // FIXED: Prevent starting if already running
            if (isListening) {
                console.log('üé§ Recognition already running, skipping start');
                return;
            }
            
            try {
                // FIXED: Always stop voice commands first to prevent conflicts
                if (isVoiceCommandListening) {
                    console.log('üõë Stopping voice commands to start speech recognition');
                    stopVoiceCommands();
                }
                
                // FIXED: Wait for voice commands to fully stop
                setTimeout(() => {
                    try {
                        recognition.start();
                        console.log('‚úÖ Speech recognition started successfully');
                    } catch (error) {
                        console.error('‚ùå Error starting recognition:', error);
                        updateStatus('‚ùå Error starting recognition: ' + error.message);
                        isListening = false;
                        updateListenButton();
                    }
                }, 200);
                
            } catch (error) {
                console.error('‚ùå Error in startListening:', error);
                updateStatus('‚ùå Error starting recognition: ' + error.message);
                isListening = false;
                updateListenButton();
            }
        }

        function updateListenButton() {
            const listenButton = document.getElementById('listenButton');
            if (listenButton) {
                if (isListening) {
                    listenButton.textContent = 'STOP LISTENING';
                    listenButton.className = 'control-btn btn-stop';
                } else {
                    listenButton.textContent = 'START TALKING';
                    listenButton.className = 'control-btn btn-listen';
                }
            }
        }

        function updateStatus(message) {
            const statusText = document.getElementById('statusText');
            if (statusText) statusText.textContent = message;
        }

        // FIXED: Function to clear speech display
        function updateSpeechDisplaySingle(currentPhrase) {
            const recognizedTextEl = document.getElementById('recognizedText');
            if (recognizedTextEl) {
                if (!currentPhrase || currentPhrase === '') {
                    // FIXED: Clear display completely
                    recognizedTextEl.innerHTML = '<div style="color: #666; font-style: italic; text-align: center; padding: 20px;">Ready for your next phrase...</div>';
                } else {
                    // Show the current phrase
                    const html = `<div class="final-phrase" style="font-size: 20px; font-weight: bold; border: 2px solid #0099cc;">
                                    ‚úÖ CAPTURED: ${currentPhrase}
                                 </div>
                                 <div style="color: #999; font-size: 12px; margin-top: 12px; text-align: center; padding: 6px; background: #f9f9f9; border-radius: 4px;">
                                    üé§ Speak your next phrase...
                                 </div>`;
                    recognizedTextEl.innerHTML = html;
                }
            }
        }

        function clearSpeechText() {
            phraseHistory = [];
            lastProcessedPhrase = '';
            lastPhraseTime = 0;
            pendingPhrase = null;
            
            lastVoiceCommand = '';
            lastVoiceCommandTime = 0;
            
            if (speechTimeoutId) {
                clearTimeout(speechTimeoutId);
                speechTimeoutId = null;
            }
            
            const recognizedTextEl = document.getElementById('recognizedText');
            if (recognizedTextEl) {
                recognizedTextEl.innerHTML = '<div style="color: #666; font-style: italic; text-align: center; padding: 20px;">Say something and your phrase will appear here...</div>';
            }
            
            console.log('üóëÔ∏è Speech text and command history cleared');
        }

        function clearTextInput() {
            const textInput = document.getElementById('largeTextInputField');
            if (textInput) textInput.value = '';
        }

        function updateTextSpeakButton() {
            const speakBtn = document.getElementById('speakTextBtn');
            if (speakBtn) {
                speakBtn.disabled = false;
                speakBtn.style.opacity = '1';
            }
        }

        // === SESSION TIMEOUT ===
        function resetSessionTimeout() {
            if (sessionTimeoutId) clearTimeout(sessionTimeoutId);
            sessionTimeoutId = setTimeout(() => {
                if (isListening && currentPage === 'speech') {
                    try {
                        if (recognition) recognition.abort();
                    } catch (e) {
                        console.log('Error aborting recognition on timeout:', e);
                    }
                    isListening = false;
                    updateListenButton();
                    updateStatus('‚è∞ Session timeout (3 minutes) - Click "START TALKING" to restart');
                }
                clearSessionTimeout();
            }, SESSION_TIMEOUT);
        }

        function clearSessionTimeout() {
            if (sessionTimeoutId) {
                clearTimeout(sessionTimeoutId);
                sessionTimeoutId = null;
            }
        }

        // === CONTACTS ===
        function initializeContacts() {
            contacts = [
                { name: 'Emergency Services', phone: '911' },
                { name: 'Demo Contact 1', phone: '(555) 123-4567' },
                { name: 'Demo Contact 2', phone: '(555) 987-6543' },
                { name: 'Demo Contact 3', phone: '(555) 246-8135' }
            ];
            filteredContacts = contacts.slice();
        }

        async function loadAllContacts() {
            const contactsList = document.getElementById('contactsList');
            const loadingSection = document.getElementById('contactLoadingSection');
            
            if (loadingSection) loadingSection.style.display = 'none';
            
            if (contactsList) {
                contactsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #669900; background: #f0f8ff; border-radius: 8px; border: 2px solid #669900;">
                        <p><strong>üìû LOADING ALL CONTACTS</strong></p>
                        <p style="margin: 10px 0;">Opening contact picker...</p>
                    </div>
                `;
            }
            
            try {
                if ('contacts' in navigator && 'ContactsManager' in window) {
                    const props = ['name', 'tel'];
                    const opts = { multiple: true };
                    const contactList = await navigator.contacts.select(props, opts);
                    
                    if (contactList && contactList.length > 0) {
                        const processedContacts = [];
                        contactList.forEach(contact => {
                            const names = contact.name || ['Unknown Contact'];
                            const phones = contact.tel || [];
                            const contactName = names[0] || 'Unknown Contact';
                            
                            if (phones.length > 0) {
                                phones.forEach((phone, phoneIndex) => {
                                    processedContacts.push({
                                        name: phones.length > 1 ? `${contactName} (${phoneIndex + 1})` : contactName,
                                        phone: phone
                                    });
                                });
                            } else {
                                processedContacts.push({
                                    name: contactName,
                                    phone: 'No phone number'
                                });
                            }
                        });
                        
                        const uniqueContacts = processedContacts.filter((contact, index, self) =>
                            index === self.findIndex(c => 
                                c.name === contact.name && c.phone === contact.phone
                            )
                        );
                        
                        contacts = uniqueContacts.sort((a, b) => a.name.localeCompare(b.name));
                        filteredContacts = contacts.slice();
                        displayRealContactsOnPhonePage();
                    } else {
                        throw new Error('No contacts selected');
                    }
                } else {
                    throw new Error('Contacts API not supported on this device/browser');
                }
            } catch (error) {
                handleContactLoadingError(error, contactsList);
            }
        }

        async function loadSelectedContacts() {
            const contactsList = document.getElementById('contactsList');
            const loadingSection = document.getElementById('contactLoadingSection');
            
            if (loadingSection) loadingSection.style.display = 'none';
            
            if (contactsList) {
                contactsList.innerHTML = `
                    <div style="padding: 16px; text-align: center; color: #0099cc; background: #f0f8ff; border-radius: 8px;">
                        <p><strong>üìã Choose Specific Contacts</strong></p>
                        <p>‚è≥ Opening contact picker...</p>
                    </div>
                `;
            }
            
            try {
                if ('contacts' in navigator && 'ContactsManager' in window) {
                    const props = ['name', 'tel'];
                    const opts = { multiple: true };
                    const contactList = await navigator.contacts.select(props, opts);
                    
                    if (contactList.length > 0) {
                        const processedContacts = contactList.map(contact => {
                            const name = (contact.name && contact.name[0]) ? contact.name[0] : 'Unknown';  
                            const phone = (contact.tel && contact.tel[0]) ? contact.tel[0] : 'No phone';
                            return { name, phone };
                        });
                        
                        const uniqueContacts = processedContacts.filter((contact, index, self) => 
                            index === self.findIndex(c => c.name === contact.name && c.phone === contact.phone)
                        );
                        
                        contacts = uniqueContacts.sort((a, b) => a.name.localeCompare(b.name));
                        filteredContacts = contacts.slice();
                        displayRealContactsOnPhonePage();
                    } else {
                        if (contactsList) {
                            contactsList.innerHTML = `
                                <div style="padding: 20px; text-align: center; color: #ff6600; border: 2px solid #ff6600; border-radius: 8px;">
                                    <p><strong>üì± No Contacts Selected</strong></p>
                                    <p>Demo contacts remain available</p>
                                </div>
                            `;
                        }
                        setTimeout(() => displayContactsOnPhonePage(), 3000);
                    }
                } else {
                    throw new Error('Contacts API not supported on this device/browser');
                }
            } catch (error) {
                handleContactLoadingError(error, contactsList);
            }
        }

        function handleContactLoadingError(error, contactsList) {
            let errorMessage = '';
            if (error.name === 'NotAllowedError') {
                errorMessage = `<p><strong>üì± Permission Denied</strong></p><p>You denied contact access</p>`;
            } else if (error.name === 'AbortError') {
                errorMessage = `<p><strong>üì± Contact Selection Cancelled</strong></p>`;
            } else if (error.message.includes('not supported')) {
                errorMessage = `<p><strong>üì± Contacts API Not Supported</strong></p><p>Requires Chrome Android or Safari iOS</p>`;
            } else {
                errorMessage = `<p><strong>üì± Contact Loading Error</strong></p><p>${error.message || 'Unknown error'}</p>`;
            }
            
            if (contactsList) {
                contactsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #cc0000; border: 2px solid #cc0000; border-radius: 8px;">
                        ${errorMessage}
                        <p style="margin-top: 15px;">Demo contacts will remain available</p>
                    </div>
                `;
            }
            
            setTimeout(() => displayContactsOnPhonePage(), 4000);
        }

        function displayRealContactsOnPhonePage() {
            const contactsList = document.getElementById('contactsList');
            if (!contactsList) return;
            
            contactsList.innerHTML = '';

            const successHeader = document.createElement('div');
            successHeader.style.cssText = 'padding: 12px; text-align: center; font-weight: bold; color: white; background: #28a745; border-radius: 8px; margin-bottom: 8px;';
            successHeader.innerHTML = `‚úÖ SUCCESS: ${filteredContacts.length} REAL contacts loaded!`;
            contactsList.appendChild(successHeader);

            filteredContacts.forEach((contact) => {
                const contactEl = document.createElement('div');
                contactEl.className = 'contact-item';
                contactEl.style.backgroundColor = '#e8f5e8';
                contactEl.innerHTML = `<div class="contact-name">${contact.name}</div><div class="contact-phone">${contact.phone}</div>`;
                contactEl.addEventListener('click', () => callContact(contact));
                contactsList.appendChild(contactEl);
            });

            const footerNote = document.createElement('div');
            footerNote.style.cssText = 'padding: 8px; text-align: center; font-size: 12px; color: #28a745; font-weight: bold; margin-top: 8px;';
            footerNote.textContent = 'üì± These are YOUR real contacts - searchable and callable!';
            contactsList.appendChild(footerNote);
        }

        function displayContactsOnPhonePage() {
            const contactsList = document.getElementById('contactsList');
            if (!contactsList) return;
            
            contactsList.innerHTML = '';
            
            if (filteredContacts.length === 0) {
                contactsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;"><p><strong>üì± No contacts found</strong></p></div>';
                return;
            }

            const headerDiv = document.createElement('div');
            headerDiv.style.cssText = 'padding: 12px; text-align: center; font-weight: bold; color: #669900; background: #f0f8ff; border-radius: 8px; margin-bottom: 8px;';
            headerDiv.textContent = `üì± ${filteredContacts.length} contacts available - Tap any contact to call`;
            contactsList.appendChild(headerDiv);

            filteredContacts.forEach((contact) => {
                const contactEl = document.createElement('div');
                contactEl.className = 'contact-item';
                contactEl.innerHTML = `<div class="contact-name">${contact.name}</div><div class="contact-phone">${contact.phone}</div>`;
                contactEl.addEventListener('click', () => callContact(contact));
                contactsList.appendChild(contactEl);
            });
        }

        function filterContacts(searchTerm) {
            if (!searchTerm.trim()) {
                filteredContacts = contacts.slice();
            } else {
                const searchLower = searchTerm.toLowerCase().trim();
                filteredContacts = contacts.filter(contact => {
                    return contact.name.toLowerCase().includes(searchLower) ||
                           contact.phone.replace(/[^0-9]/g, '').includes(searchTerm.replace(/[^0-9]/g, ''));
                });
            }
            displayContactsOnPhonePage();
        }

        function callContact(contact) {
            const phoneNumber = contact.phone.replace(/[^0-9]/g, '');
            if (phoneNumber) {
                window.location.href = `tel:${phoneNumber}`;
            }
        }

        // === WEATHER ===
        function getUserLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        userLocation = {
                            lat: position.coords.latitude,
                            lon: position.coords.longitude
                        };
                        console.log('‚úÖ Got precise location:', userLocation);
                    },
                    function(error) {
                        console.log('‚ùå Location error, using Wentzville, MO:', error);
                        // FIXED: Use actual Wentzville, MO coordinates
                        userLocation = { lat: 38.8117, lon: -90.8529 };
                    },
                    {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 300000 // 5 minutes
                    }
                );
            } else {
                // FIXED: Default to Wentzville, MO (your location)
                userLocation = { lat: 38.8117, lon: -90.8529 };
                console.log('üìç Using default Wentzville, MO location');
            }
        }

        async function showCurrentWeather() {
            showWeatherDisplay('Current Weather', 'Loading current weather...');
            
            try {
                const { lat, lon } = userLocation || { lat: 40.7128, lon: -74.0060 };
                
                // FIXED: Get weather data
                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,wind_speed_10m,weather_code&timezone=auto`);
                const weatherData = await weatherResponse.json();
                
                // FIXED: Get precise city name with multiple fallback methods
                let cityName = 'Unknown Location';
                try {
                    // Method 1: Try BigDataCloud for most accurate city data
                    const locationResponse1 = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=en`);
                    const locationData1 = await locationResponse1.json();
                    
                    // Try to get the most specific location
                    if (locationData1.city) {
                        cityName = locationData1.city;
                    } else if (locationData1.locality) {
                        cityName = locationData1.locality;
                    } else if (locationData1.principalSubdivision) {
                        cityName = locationData1.principalSubdivision;
                    }
                    
                    // If still not specific enough, try another service
                    if (cityName === 'Unknown Location' || cityName === 'St. Louis' || cityName.includes('County') || cityName.includes('Metropolitan')) {
                        try {
                            // Method 2: Try OpenStreetMap Nominatim for more precise location
                            const locationResponse2 = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=14&addressdetails=1`);
                            const locationData2 = await locationResponse2.json();
                            
                            if (locationData2.address) {
                                // Try to get the most specific location from OSM
                                const addr = locationData2.address;
                                if (addr.city) {
                                    cityName = addr.city;
                                } else if (addr.town) {
                                    cityName = addr.town;
                                } else if (addr.village) {
                                    cityName = addr.village;
                                } else if (addr.suburb && addr.county) {
                                    cityName = `${addr.suburb}, ${addr.county}`;
                                } else if (addr.neighbourhood && addr.city_district) {
                                    cityName = `${addr.neighbourhood}, ${addr.city_district}`;
                                } else if (addr.hamlet) {
                                    cityName = addr.hamlet;
                                }
                            }
                        } catch (osmError) {
                            console.log('OSM geocoding failed:', osmError);
                        }
                    }
                    
                    // Final fallback
                    if (cityName === 'Unknown Location') {
                        cityName = `${lat.toFixed(3)}, ${lon.toFixed(3)}`;
                    }
                    
                } catch (locationError) {
                    console.log('Could not get precise location:', locationError);
                    cityName = `${lat.toFixed(3)}, ${lon.toFixed(3)}`;
                }
                
                const temperature = Math.round(weatherData.current.temperature_2m * 9/5 + 32);
                const humidity = weatherData.current.relative_humidity_2m;
                const windSpeed = Math.round(weatherData.current.wind_speed_10m * 0.621371);
                const conditions = getWeatherDescription(weatherData.current.weather_code);
                
                const weatherContent = `
                    <div style="text-align: center; padding: 10px;">
                        <div style="font-size: 16px; font-weight: bold; color: #0099cc; margin-bottom: 8px;">üìç ${cityName}</div>
                        <div style="font-size: 28px; font-weight: bold; color: #0099cc; margin-bottom: 8px;">${temperature}¬∞F</div>
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 16px;">${conditions}</div>
                        <div style="font-size: 14px; line-height: 1.6;">
                            <div><strong>Humidity:</strong> ${humidity}%</div>
                            <div><strong>Wind:</strong> ${windSpeed} mph</div>
                        </div>
                    </div>
                `;
                
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = weatherContent;
            } catch (error) {
                console.error('Weather error:', error);
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = '<div style="text-align: center; padding: 20px;">Unable to load weather data.</div>';
            }
        }

        async function showHourlyWeather() {
            showWeatherDisplay('Next 24 Hours', 'Loading 24-hour forecast...');
            
            try {
                const { lat, lon } = userLocation || { lat: 38.8117, lon: -90.8529 };
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,weather_code&timezone=auto&forecast_days=2`);
                const data = await response.json();
                
                const now = new Date();
                const currentHour = now.getHours();
                
                let hourlyData = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); gap: 4px; padding: 10px; max-height: 400px; overflow-y: auto;">';
                
                let startIndex = 0;
                for (let i = 0; i < data.hourly.time.length; i++) {
                    const timeDate = new Date(data.hourly.time[i]);
                    if (timeDate.getHours() === currentHour && 
                        timeDate.getDate() === now.getDate()) {
                        startIndex = i;
                        break;
                    }
                }
                
                // FIXED: Show EVERY hour for 24 hours (not every 2 hours)
                for (let i = startIndex; i < Math.min(startIndex + 24, data.hourly.time.length); i++) {
                    const time = new Date(data.hourly.time[i]);
                    const hour = time.getHours();
                    const temp = Math.round(data.hourly.temperature_2m[i] * 9/5 + 32);
                    const weatherCode = data.hourly.weather_code[i];
                    const conditions = getWeatherDescription(weatherCode);
                    
                    const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                    const ampm = hour >= 12 ? 'PM' : 'AM';
                    
                    const isCurrent = i === startIndex;
                    const timeDisplay = isCurrent ? 'NOW' : `${displayHour}${ampm}`;
                    const bgColor = isCurrent ? '#0099cc' : '#f0f8ff';
                    const textColor = isCurrent ? 'white' : 'black';
                    
                    // FIXED: Every single hour displayed
                    hourlyData += `
                        <div class="hourly-item" style="background-color: ${bgColor}; color: ${textColor}; padding: 6px; text-align: center; font-size: 10px; border-radius: 4px;">
                            <div style="font-weight: bold; font-size: 11px;">${timeDisplay}</div>
                            <div style="font-size: 12px; font-weight: bold; margin: 2px 0;">${temp}¬∞</div>
                            <div style="font-size: 9px; opacity: 0.9; line-height: 1.1;">${conditions}</div>
                        </div>
                    `;
                }
                hourlyData += '</div>';
                
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = hourlyData;
            } catch (error) {
                console.error('Hourly weather error:', error);
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = '<div style="text-align: center; padding: 20px;">Unable to load 24-hour forecast.</div>';
            }
        }

        async function showWeeklyWeather() {
            showWeatherDisplay('7-Day Forecast', 'Loading 7-day forecast...');
            
            try {
                const { lat, lon } = userLocation || { lat: 40.7128, lon: -74.0060 };
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_max,temperature_2m_min,weather_code&timezone=auto&forecast_days=7`);
                const data = await response.json();
                
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                let weeklyData = '<div style="display: grid; gap: 6px; padding: 10px;">';
                
                for (let i = 0; i < Math.min(7, data.daily.time.length); i++) {
                    const date = new Date(data.daily.time[i]);
                    const dayName = days[date.getDay()];
                    const high = Math.round(data.daily.temperature_2m_max[i] * 9/5 + 32);
                    const low = Math.round(data.daily.temperature_2m_min[i] * 9/5 + 32);
                    const conditions = getWeatherDescription(data.daily.weather_code[i]);
                    
                    weeklyData += `
                        <div class="weekly-item">
                            <div class="day-name">${dayName}</div>
                            <div class="day-temps">${high}¬∞/${low}¬∞</div>
                            <div class="day-condition">${conditions}</div>
                        </div>
                    `;
                }
                weeklyData += '</div>';
                
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = weeklyData;
            } catch (error) {
                console.error('Weekly weather error:', error);
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = '<div style="text-align: center; padding: 20px;">Unable to load 7-day forecast.</div>';
            }
        }

        function showWeatherDisplay(title, content) {
            const weatherDisplay = document.getElementById('weatherDisplay');
            const weatherTitle = document.getElementById('weatherTitle');
            const weatherContent = document.getElementById('weatherContent');
            
            if (weatherTitle) weatherTitle.textContent = title;
            if (weatherContent) weatherContent.innerHTML = `<div style="text-align: center; padding: 20px;">${content}</div>`;
            if (weatherDisplay) weatherDisplay.classList.remove('hidden');
        }

        function hideWeather() {
            const weatherDisplay = document.getElementById('weatherDisplay');
            if (weatherDisplay) {
                weatherDisplay.classList.add('hidden');
                console.log('‚úÖ Weather display hidden');
            }
        }

        function getWeatherDescription(code) {
            const weatherCodes = {
                0: 'Clear sky', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast',
                45: 'Fog', 48: 'Depositing rime fog',
                51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle',
                61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain',
                71: 'Slight snow', 73: 'Moderate snow', 75: 'Heavy snow',
                80: 'Slight rain showers', 81: 'Moderate rain showers', 82: 'Violent rain showers',
                95: 'Thunderstorm', 96: 'Thunderstorm with hail', 99: 'Thunderstorm with heavy hail'
            };
            return weatherCodes[code] || 'Unknown';
        }

        // === SWIPE GESTURES ===
        function setupSwipeGestures() {
            const swipeBottom = document.getElementById('swipeBottom');
            const swipeLeft = document.getElementById('swipeLeft');
            const swipeRight = document.getElementById('swipeRight');
            
            let touchStartX = 0;
            let touchStartY = 0;
            const minSwipeDistance = 50;

            if (swipeBottom) {
                swipeBottom.addEventListener('touchstart', function(e) {
                    touchStartY = e.changedTouches[0].clientY;
                    e.preventDefault();
                }, { passive: false });

                swipeBottom.addEventListener('touchend', function(e) {
                    const touchEndY = e.changedTouches[0].clientY;
                    const swipeDistance = touchStartY - touchEndY;
                    if (swipeDistance > minSwipeDistance) {
                        showCurrentWeather();
                    }
                    e.preventDefault();
                }, { passive: false });
            }

            if (swipeLeft) {
                swipeLeft.addEventListener('touchstart', function(e) {
                    touchStartX = e.changedTouches[0].clientX;
                    e.preventDefault();
                }, { passive: false });

                swipeLeft.addEventListener('touchend', function(e) {
                    const touchEndX = e.changedTouches[0].clientX;
                    const swipeDistance = touchEndX - touchStartX;
                    if (swipeDistance > minSwipeDistance) {
                        showHourlyWeather();
                    }
                    e.preventDefault();
                }, { passive: false });
            }

            if (swipeRight) {
                swipeRight.addEventListener('touchstart', function(e) {
                    touchStartX = e.changedTouches[0].clientX;
                    e.preventDefault();
                }, { passive: false });

                swipeRight.addEventListener('touchend', function(e) {
                    const touchEndX = e.changedTouches[0].clientX;
                    const swipeDistance = touchStartX - touchEndX;
                    if (swipeDistance > minSwipeDistance) {
                        showWeeklyWeather();
                    }
                    e.preventDefault();
                }, { passive: false });
            }
        }

        // === SETTINGS ===
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('leslieSettings');
                if (savedSettings) {
                    Object.assign(settings, JSON.parse(savedSettings));
                }
            } catch (error) {
                console.error('Error loading settings:', error);
            }
            updateSettingsUI();
        }

        function saveSettings() {
            try {
                localStorage.setItem('leslieSettings', JSON.stringify(settings));
            } catch (error) {
                console.error('Error saving settings:', error);
            }
        }

        function updateSettingsUI() {
            const elements = {
                speedSlider: document.getElementById('speechSpeedSlider'),
                pauseSlider: document.getElementById('pauseBetweenWordsSlider'),
                voiceSwitch: document.getElementById('speakVoiceCommandsSwitch'),
                enhancedSwitch: document.getElementById('autoEnhancedSwitch'),
                enhancedModeSwitch: document.getElementById('enhancedModeSwitch'),
                apiKeyInput: document.getElementById('apiKeyInput')
            };

            if (elements.speedSlider) elements.speedSlider.value = settings.speechSpeed;
            if (elements.pauseSlider) elements.pauseSlider.value = settings.pauseBetweenWords;
            if (elements.voiceSwitch) elements.voiceSwitch.checked = settings.speakVoiceCommands;
            if (elements.enhancedSwitch) elements.enhancedSwitch.checked = settings.autoEnhanced;
            if (elements.enhancedModeSwitch) elements.enhancedModeSwitch.checked = settings.enhancedMode;
            if (elements.apiKeyInput) elements.apiKeyInput.value = settings.apiKey;

            updateSpeechSpeed(settings.speechSpeed);
            updatePauseBetweenWords(settings.pauseBetweenWords);
            updateVoiceCommandSetting(settings.speakVoiceCommands);
            updateAutoEnhanced(settings.autoEnhanced);
            updateEnhancedMode(settings.enhancedMode);
        }

        function updateSpeechSpeed(value) {
            settings.speechSpeed = parseFloat(value);
            const label = document.getElementById('speechSpeedValue');
            const slider = document.getElementById('speechSpeedSlider');
            
            if (label) {
                // FIXED: Properly round and format to 1 decimal place
                const formattedValue = Math.round(parseFloat(value) * 10) / 10;
                label.textContent = formattedValue === 1.0 ? 'Normal (1.0x)' : formattedValue + 'x';
            }
            if (slider) {
                slider.value = value;
            }
            saveSettings();
        }

        function updatePauseBetweenWords(value) {
            settings.pauseBetweenWords = parseFloat(value);
            const label = document.getElementById('pauseBetweenWordsValue');
            const slider = document.getElementById('pauseBetweenWordsSlider');
            
            if (label) {
                // FIXED: Properly round and format to 1 decimal place  
                const formattedValue = Math.round(parseFloat(value) * 10) / 10;
                label.textContent = formattedValue + ' seconds';
            }
            if (slider) {
                slider.value = value;
            }
            
            console.log(`üîß Pause setting updated to: ${value} seconds`);
            
            // FIXED: Apply immediately to speech recognition if running
            if (recognition && isListening) {
                console.log('üîÑ Restarting speech recognition with new pause setting');
                try {
                    recognition.abort();
                } catch(e) {
                    console.log('Error aborting recognition:', e);
                }
                setTimeout(() => {
                    if (currentPage === 'speech') {
                        try {
                            recognition.start();
                            const formattedValue = Math.round(parseFloat(value) * 10) / 10;
                            updateStatus(`üé§ Listening with ${formattedValue}s pause tolerance`);
                        } catch(e) {
                            updateStatus('‚ùå Please click START TALKING to restart');
                        }
                    }
                }, 1000);
            }
            
            if (voiceCommandRecognition) {
                console.log('üîÑ Updating voice command timing with new pause setting');
                if (isVoiceCommandListening && currentPage !== 'speech') {
                    try {
                        voiceCommandRecognition.abort();
                    } catch(e) {
                        console.log('Error aborting voice commands:', e);
                    }
                    setTimeout(() => {
                        if (currentPage !== 'speech' && !isListening && microphonePermissionGranted && isInitialized) {
                            startVoiceCommands();
                        }
                    }, Math.max((parseFloat(value) * 1000), 500));
                }
            }
            
            saveSettings();
        }

        function updateVoiceCommandSetting(checked) {
            settings.speakVoiceCommands = checked;
            const label = document.getElementById('speakVoiceCommandsLabel');
            const switchEl = document.getElementById('speakVoiceCommandsSwitch');
            
            if (label) {
                label.textContent = 'Voice Command Speech: ' + (checked ? 'ON' : 'OFF');
            }
            if (switchEl) {
                switchEl.checked = checked;
            }
            saveSettings();
        }

        function updateAutoEnhanced(checked) {
            settings.autoEnhanced = checked;
            saveSettings();
        }

        function updateEnhancedMode(checked) {
            settings.enhancedMode = checked;
            const label = document.getElementById('enhancedModeLabel');
            const switchEl = document.getElementById('enhancedModeSwitch');
            
            if (label) {
                label.textContent = 'Enhanced Mode: ' + (checked ? 'ON' : 'OFF');
            }
            if (switchEl) {
                switchEl.checked = checked;
            }
            saveSettings();
        }

        function saveApiKey(value) {
            settings.apiKey = value;
            saveSettings();
            updateEnhancedSectionVisibility();
        }

        function updateEnhancedSectionVisibility() {
            const enhancedSection = document.getElementById('enhancedSection');
            if (enhancedSection && settings.apiKey) {
                enhancedSection.classList.add('show');
            } else if (enhancedSection) {
                enhancedSection.classList.remove('show');
            }
        }

        function startEnhancedRecognition() {
            if (!settings.apiKey) {
                alert('Please enter your OpenAI API key in Settings to use Enhanced Recognition.');
                showPage('settings');
                return;
            }
            alert('Enhanced Recognition requires OpenAI API integration. This is a demo placeholder.');
        }

        // === INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ DOM loaded, initializing Leslie Speech Assistant...');
            try {
                initApp();
            } catch (error) {
                console.error('‚ùå Error during DOMContentLoaded initialization:', error);
            }
        });

        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && currentPage !== 'speech' && !isListening && !isVoiceCommandListening && microphonePermissionGranted && isInitialized) {
                setTimeout(() => startVoiceCommands(), 1000);
            }
        });

        // Prevent multiple initializations
        window.addEventListener('load', function() {
            if (!isInitialized) {
                console.log('üîÑ Window loaded - attempting backup initialization...');
                try {
                    initApp();
                } catch (error) {
                    console.error('‚ùå Error during backup initialization:', error);
                }
            }
        });
    </script>
</body>
</html>
