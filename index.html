<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leslie Speech Assistant</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background-color: #ffffff;
            color: #000000;
            overflow-x: hidden;
            touch-action: pan-y;
        }
        .container {
            max-width: 100vw;
            min-height: 100vh;
            padding: 16px;
            position: relative;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 16px;
        }
        .header h1 {
            font-size: 24px;
            font-weight: bold;
            color: #0099cc;
            flex-grow: 1;
            text-align: center;
        }
        .settings-btn {
            width: 48px;
            height: 48px;
            background: transparent;
            border: none;
            cursor: pointer;
            border-radius: 50%;
            padding: 8px;
            font-size: 20px;
        }
        .settings-btn:hover { background-color: #f0f0f0; }
        .page { display: none; width: 100%; }
        .page.active { display: block; }
        .home-page {
            text-align: center;
            padding: 16px;
        }
        .welcome-text {
            font-size: 18px;
            margin-bottom: 32px;
            line-height: 1.5;
        }
        .main-button {
            width: 100%;
            height: 80px;
            font-size: 20px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px;
            margin-bottom: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .main-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.3);
        }
        .main-button:active { transform: translateY(0); }
        .btn-talking { background-color: #0099cc; }
        .btn-texting { background-color: #9933cc; }
        .btn-phone { background-color: #669900; }
        .btn-commands { background-color: #ff8800; }
        .tips-box {
            background-color: #f0f0f0;
            padding: 16px;
            border-radius: 8px;
            margin-top: 16px;
            line-height: 1.4;
            font-size: 14px;
            font-weight: bold;
        }
        .page-header {
            display: flex;
            align-items: center;
            padding: 16px;
            color: white;
            margin-bottom: 16px;
            border-radius: 8px;
        }
        .page-header h2 {
            flex-grow: 1;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
        }
        .close-btn {
            width: 48px;
            height: 48px;
            background: transparent;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 50%;
            font-size: 24px;
        }
        .close-btn:hover { background-color: rgba(255,255,255,0.2); }
        .header-speech { background-color: #0099cc; }
        .header-phone { background-color: #669900; }
        .header-commands { background-color: #ff8800; }
        .header-text { background-color: #9933cc; }
        .header-settings { background-color: #0099cc; }
        .speech-page {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px);
            overflow-y: auto;
            padding-bottom: 100px;
        }
        .status-text {
            text-align: center;
            font-size: 16px;
            font-weight: bold;
            color: #0099cc;
            margin-bottom: 16px;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .speech-display {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 16px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .speech-header {
            background-color: #f0f0f0;
            padding: 8px;
            font-size: 14px;
            font-weight: bold;
            color: #0099cc;
        }
        .speech-content {
            padding: 12px;
            flex-grow: 1;
            max-height: 200px;
            overflow-y: auto;
            min-height: 150px;
        }
        .speech-text {
            font-size: 16px;
            line-height: 1.4;
            color: #000;
        }
        .enhanced-section {
            background-color: #f8f9fa;
            border: 2px solid #6f42c1;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            display: none;
        }
        .enhanced-section.show { display: block; }
        .enhanced-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .enhanced-title { font-size: 14px; font-weight: bold; color: #6f42c1; }
        .cost-info { font-size: 12px; color: #666; }
        .enhanced-status {
            font-size: 14px;
            color: #666;
            margin-bottom: 8px;
            min-height: 20px;
        }
        .control-row {
            display: flex;
            justify-content: center;
            gap: 8px;
            align-items: center;
            margin: 16px 0;
            padding: 16px;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 2px solid #0099cc;
            z-index: 1000;
            box-shadow: 0 -4px 8px rgba(0,0,0,0.1);
        }
        .control-btn {
            height: 70px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            width: 300px;
            max-width: 80%;
        }
        .icon-btn {
            width: 70px;
            height: 70px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn-listen { background-color: #0099cc; }
        .btn-stop { background-color: #cc0000; }
        .btn-enhanced { background-color: #6f42c1; }
        .btn-clear { background-color: #ffaa00; }
        .btn-home {
            background-color: #0099cc;
            height: 70px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            width: 300px;
            max-width: 80%;
            margin: 0 auto;
            display: block;
        }
        .text-input {
            width: 100%;
            padding: 16px;
            margin: 8px 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 18px;
            resize: vertical;
            min-height: 120px;
            background: #f9f7fa;
        }
        .large-text-input {
            flex-grow: 1;
            min-height: 260px;
            margin-top: 8px;
        }
        .text-input-page {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 100px);
        }
        .text-input-content {
            flex-grow: 1;
            padding: 16px;
            padding-bottom: 100px;
            position: relative;
        }
        .speak-text-container {
            position: relative;
            margin-top: 16px;
        }
        .speak-phrase-btn {
            background: #9933cc;
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 4px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            position: absolute;
            right: 8px;
            top: -48px;
            z-index: 10;
        }
        .speak-phrase-btn:hover { background: #7a2a99; }
        .speak-phrase-btn:disabled { background: #ccc; cursor: not-allowed; opacity: 0.5; }
        .contact-search-section {
            padding: 12px;
            background-color: #f0f0f0;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        .contact-search-input {
            width: 100%;
            height: 50px;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #669900;
            border-radius: 8px;
            margin-top: 8px;
        }
        .contact-list-container {
            padding: 8px;
            flex-grow: 1;
            max-height: 400px;
            overflow-y: auto;
        }
        .contacts-list {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 8px;
            background-color: white;
            min-height: 300px;
        }
        .contact-item {
            padding: 12px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .contact-item:hover { background-color: #f0f0f0; }
        .contact-item.selected {
            background-color: #669900;
            color: white;
        }
        .contact-name {
            font-weight: bold;
            font-size: 16px;
        }
        .contact-phone {
            color: #666;
            font-size: 14px;
            margin-top: 2px;
        }
        .contact-item.selected .contact-phone { color: #fff; }
        .phone-home-section {
            padding: 16px;
            text-align: center;
            background-color: #f0f0f0;
            border-top: 2px solid #669900;
            margin-top: 16px;
        }
        .settings-section {
            background-color: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .settings-title {
            font-size: 16px;
            font-weight: bold;
            color: #000;
            margin-bottom: 8px;
        }
        .settings-description {
            font-size: 12px;
            color: #666;
            margin-bottom: 12px;
        }
        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            margin-bottom: 8px;
        }
        .setting-value {
            text-align: center;
            font-size: 14px;
            font-weight: bold;
            color: #0099cc;
        }
        .switch {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        .switch input { margin-right: 8px; transform: scale(1.5); }
        .back-btn {
            width: 200px;
            height: 70px;
            background-color: #0099cc;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin: 16px auto 32px;
            display: block;
        }
        .weather-display {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 3px solid #0099cc;
            border-radius: 12px;
            padding: 20px;
            z-index: 1000;
            width: 90vw;
            max-width: 500px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        .weather-display.hidden { display: none; }
        .weather-title {
            font-size: 20px;
            font-weight: bold;
            color: #0099cc;
            text-align: center;
            margin-bottom: 16px;
        }
        .weather-content {
            margin-bottom: 16px;
            line-height: 1.6;
            text-align: center;
        }
        .weather-controls {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        .weather-btn {
            padding: 8px 16px;
            background: #0099cc;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
        }
        .weather-btn:hover { background: #0077aa; }
        .hourly-forecast, .weekly-forecast {
            display: grid;
            gap: 8px;
        }
        .hourly-item, .weekly-item {
            background: #f0f8ff;
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 12px;
        }
        .weekly-item {
            display: grid;
            grid-template-columns: 80px 60px 1fr;
            gap: 8px;
            align-items: center;
            font-size: 14px;
        }
        .day-name { font-weight: bold; }
        .day-temps { color: #0099cc; font-weight: bold; }
        .day-condition { color: #666; }
        .swipe-edge {
            position: fixed;
            z-index: 998;
            background: rgba(0,153,204,0.3);
        }
        .swipe-bottom {
            bottom: 0;
            left: 40%;
            width: 20%;
            height: 40px;
        }
        .swipe-left {
            left: 0;
            top: 40%;
            width: 40px;
            height: 20%;
        }
        .swipe-right {
            right: 0;
            top: 40%;
            width: 40px;
            height: 20%;
        }
        .api-key-section {
            background-color: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .api-key-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            margin-top: 8px;
        }
        .contact-loading-section {
            padding: 20px;
            text-align: center;
            color: #669900;
            border: 2px solid #669900;
            border-radius: 8px;
            background-color: #f8f9fa;
            margin-bottom: 16px;
        }
        .voice-command-status {
            position: fixed;
            top: 15px;
            right: 15px;
            background: rgba(255, 193, 7, 0.9);
            color: #333;
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            border: 2px solid rgba(255, 193, 7, 0.3);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .voice-command-status.active {
            background: rgba(40, 167, 69, 0.9);
            color: white;
            display: block;
            border-color: rgba(40, 167, 69, 0.3);
            animation: pulse 2s infinite;
        }
        .voice-command-status.permission-needed {
            background: rgba(220, 53, 69, 0.9);
            color: white;
            display: block;
            border-color: rgba(220, 53, 69, 0.3);
            animation: bounce 2s infinite;
            transform: scale(1.1);
            font-size: 16px;
            padding: 12px 18px;
        }
        .voice-command-status.ready {
            background: rgba(40, 167, 69, 0.9);
            color: white;
            display: block;
            border-color: rgba(40, 167, 69, 0.3);
        }
        .voice-command-status.processing {
            background: rgba(255, 193, 7, 0.9);
            color: #333;
            display: block;
            border-color: rgba(255, 193, 7, 0.3);
        }
        .voice-command-status.speaking {
            background: rgba(153, 102, 255, 0.9);
            color: white;
            display: block;
            border-color: rgba(153, 102, 255, 0.3);
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0) scale(1.1); }
            40% { transform: translateY(-4px) scale(1.1); }
            60% { transform: translateY(-2px) scale(1.1); }
        }
        @media (max-width: 768px) {
            .container { padding: 8px; }
            .main-button { height: 70px; font-size: 18px; }
            .control-btn { width: 250px; }
            .weather-display { 
                padding: 16px;
                width: 95vw;
                max-width: 450px;
            }
            .voice-command-status {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div style="width: 48px;"></div>
            <h1>Leslie Speech Assistant</h1>
            <button class="settings-btn" id="btnSettings">⚙️</button>
        </div>

        <!-- Home Page -->
        <div id="homePage" class="page active">
            <div class="home-page">
                <div class="welcome-text">
                    👋 Welcome to Leslie!<br><br>
                    Designed for accessibility and speech assistance:<br>
                    <strong>🔇 TRUE Zero Pinging • ♿ Accessibility Focused</strong>
                </div>
                <button class="main-button btn-talking" id="btnStartTalking">
                    🎤 START TALKING
                </button>
                <button class="main-button btn-texting" id="btnStartTexting">
                    📝 START TEXTING
                </button>
                <button class="main-button btn-phone" id="btnPhoneCall">
                    📞 PHONE CALL
                </button>
                <button class="main-button btn-commands" id="btnCommands">
                    🗣️ LESLIE COMMANDS
                </button>
                <div class="tips-box">
                    ♿ <strong>Accessibility Features:</strong><br>
                    • <strong>TRUE Zero Pinging:</strong> Completely silent operation - no notification sounds<br>
                    • <strong>Slow & Steady:</strong> Patient initialization prevents rapid restart sounds<br>
                    • <strong>Adjustable Timing:</strong> "Pause Between Words" setting works everywhere<br>
                    • <strong>Voice Commands:</strong> Control everything hands-free<br>
                    • <strong>Two Modes:</strong> Free (browser-based) or Pro (Whisper accuracy)<br>
                    • <strong>Mobile Ready:</strong> Works as PWA app from home screen<br>
                    • <strong>Weather & Contacts:</strong> Swipe gestures and real contact loading
                </div>
            </div>
        </div>

        <!-- Speech Recognition Page -->
        <div id="speechPage" class="page">
            <div class="speech-page">
                <div class="page-header header-speech">
                    <h2>🔇 TRUE Zero-Ping Speech Recognition</h2>
                    <button class="close-btn" id="btnCloseSpeech">&times;</button>
                </div>
                
                <div class="status-text" id="statusText">
                    Initializing TRUE zero-ping (silent) speech recognition...
                </div>
                <div class="speech-display">
                    <div class="speech-header">
                        Silent Continuous Speech Recognition - No Sounds, No Interruptions
                    </div>
                    <div class="speech-content">
                        <div class="speech-text" id="recognizedText">
                            Your speech will appear here continuously...
                        </div>
                    </div>
                </div>
                <div class="enhanced-section" id="enhancedSection">
                    <div class="enhanced-header">
                        <div class="enhanced-title">🎯 Pro Mode (OpenAI Whisper)</div>
                        <div class="cost-info">~$0.006/minute</div>
                    </div>
                    <div class="enhanced-status" id="enhancedStatus">
                        Highest accuracy for speech impairments and unclear speech
                    </div>
                    <button class="control-btn btn-enhanced" id="enhancedButton">
                        🎯 START PRO MODE
                    </button>
                </div>
                <div class="control-row">
                    <button class="control-btn btn-listen" id="listenButton">
                        START CONTINUOUS LISTENING
                    </button>
                    <button class="icon-btn btn-clear" id="clearButton" title="Clear Text">
                        🗑️
                    </button>
                </div>
            </div>
        </div>

        <!-- Phone Call Page -->
        <div id="phonePage" class="page">
            <div class="page-header header-phone">
                <h2>📞 Your Contacts</h2>
                <button class="close-btn" id="btnClosePhone">&times;</button>
            </div>
            <div class="contact-search-section">
                <div style="font-size: 14px; font-weight: bold; color: #669900; margin-bottom: 8px;">
                    🔍 Search Your Contacts
                </div>
                <input type="text" class="contact-search-input" id="contactSearchInput" placeholder="Type to search contacts...">
            </div>
            
            <div class="contact-loading-section" id="contactLoadingSection">
                <p><strong>📱 GET YOUR REAL CONTACTS</strong></p>
                <p style="color: #333; margin: 10px 0; font-size: 16px;">Currently showing: <span style="color: #cc0000;">Demo Contacts Only</span></p>
                <p style="color: #666; font-size: 14px; margin-bottom: 15px;">
                    Choose how to load YOUR real contacts from your phone:
                </p>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button id="loadAllContactsBtn" style="margin: 5px; padding: 16px 24px; background: #669900; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        📞 LOAD ALL CONTACTS
                    </button>
                    <button id="loadSelectedContactsBtn" style="margin: 5px; padding: 16px 24px; background: #0099cc; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                        📋 SELECT SPECIFIC CONTACTS
                    </button>
                </div>
                <p style="margin-top: 12px; font-size: 12px; color: #666;">
                    <strong>📞 LOAD ALL:</strong> Opens contact picker with auto-selection attempt<br>
                    <strong>📋 SELECT:</strong> Opens contact picker for manual selection<br>
                    <strong>⚠️ Works on Chrome Android & Safari iOS only</strong>
                </p>
            </div>
            
            <div class="contact-list-container">
                <div style="font-size: 12px; color: #669900; margin-bottom: 8px; text-align: center;">
                    📱 Your contacts will appear here - Tap any contact to call
                </div>
                <div class="contacts-list" id="contactsList"></div>
            </div>
            <div class="phone-home-section">
                <button class="btn-home" id="btnPhoneHome">🏠 HOME</button>
            </div>
        </div>

        <!-- Text Input Page -->
        <div id="textInputPage" class="page">
            <div class="text-input-page">
                <div class="page-header header-text">
                    <h2>📝 Text Input</h2>
                    <button class="close-btn" id="btnCloseText">&times;</button>
                </div>
                <div class="text-input-content" style="margin-top: 10px;">
                    <div style="font-size: 14px; font-weight: bold; color: #9933cc; margin-bottom: 8px;">
                        Type your text and tap speak to have it read aloud:
                    </div>
                    <textarea class="text-input large-text-input" id="largeTextInputField" placeholder="Type what you want to say here..."></textarea>
                    
                    <div class="speak-text-container">
                        <button class="speak-phrase-btn" id="speakTextBtn" disabled>
                            🔊 SPEAK
                        </button>
                    </div>
                    
                    <div style="padding: 16px; text-align: center; background-color: #f0f0f0; margin-top: 8px; position: fixed; bottom: 0; left: 0; right: 0; z-index: 999;">
                        <button class="btn-home" id="btnTextHome">🏠 HOME</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Leslie Commands Page -->
        <div id="commandsPage" class="page">
            <div class="page-header header-commands">
                <h2>🗣️ Leslie Commands</h2>
                <button class="close-btn" id="btnCloseCommands">&times;</button>
            </div>
            <div style="padding: 16px; max-height: 70vh; overflow-y: auto; background: white; border-radius: 8px; margin: 8px;">
                <div style="font-size: 16px; line-height: 1.6; color: #333;">
                    <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #0099cc;">
                        <strong>🔇 Available Voice Commands</strong><br>
                        <span style="font-size: 14px; color: #666;">All commands operate silently and respect your "Pause Between Words" setting</span>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #28a745;">
                            <strong style="color: #28a745;">🧭 Navigation Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            • "Hey Leslie, <strong>home</strong>" - Returns to home page<br>
                            • "Hey Leslie, <strong>start talking</strong>" - Speech recognition page<br>
                            • "Hey Leslie, <strong>start texting</strong>" - Text input page<br>
                            • "Hey Leslie, <strong>phone</strong>" - Phone contacts page<br>
                            • "Hey Leslie, <strong>settings</strong>" - Settings page<br>
                            • "Hey Leslie, <strong>help</strong>" - Shows this commands list<br>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #007bff;">
                            <strong style="color: #007bff;">🌤️ Weather Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            • "Hey Leslie, <strong>weather</strong>" - Shows current weather<br>
                            • "Hey Leslie, <strong>hourly</strong>" - Shows 24-hour forecast<br>
                            • "Hey Leslie, <strong>weekly</strong>" - Shows 7-day forecast<br>
                            • "Hey Leslie, <strong>7 day</strong>" - Shows 7-day forecast<br>
                            • "Hey Leslie, <strong>close weather</strong>" - Closes weather displays<br>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #6f42c1;">
                            <strong style="color: #6f42c1;">🎙️ Recognition Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            • "Hey Leslie, <strong>free mode</strong>" - Switch to free mode<br>
                            • "Hey Leslie, <strong>pro mode</strong>" - Switch to pro mode (requires API key)<br>
                            • "Hey Leslie, <strong>stop listening</strong>" - Stops speech recognition<br>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 25px;">
                        <div style="background: #f8f9fa; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #dc3545;">
                            <strong style="color: #dc3545;">🔊 Speech Settings Commands</strong>
                        </div>
                        <div style="margin-left: 15px; font-size: 15px;">
                            • "Hey Leslie, <strong>speak faster</strong>" - Increases speech speed<br>
                            • "Hey Leslie, <strong>speak slower</strong>" - Decreases speech speed<br>
                            • "Hey Leslie, <strong>pause more</strong>" - Increases pause between words<br>
                            • "Hey Leslie, <strong>pause less</strong>" - Decreases pause between words<br>
                        </div>
                    </div>
                    
                    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107;">
                        <strong style="color: #856404;">♿ Accessibility Features</strong><br>
                        <div style="margin-top: 8px; font-size: 14px; color: #856404;">
                            • <strong>Silent Operation:</strong> TRUE zero-ping - no notification sounds ever<br>
                            • <strong>Patient Timing:</strong> Slow, respectful restarts prevent rapid fire sounds<br>
                            • <strong>Consistent Timing:</strong> "Pause Between Words" setting applies to all recognition<br>
                            • <strong>Visual Feedback:</strong> Clear status indicators<br>
                            • <strong>Large Touch Targets:</strong> Easy button activation<br>
                            • <strong>Swipe Gestures:</strong> Quick access to weather (bottom/left/right edges)<br>
                        </div>
                    </div>
                </div>
            </div>
            <div style="padding: 16px; text-align: center;">
                <button class="btn-home" id="btnCommandsHome">🏠 HOME</button>
            </div>
        </div>

        <!-- Settings Page -->
        <div id="settingsPage" class="page">
            <div class="page-header header-settings">
                <h2>⚙️ Leslie Settings</h2>
                <button class="close-btn" id="btnCloseSettings">&times;</button>
            </div>
            <div style="max-height: 500px; overflow-y: auto; padding: 0 8px;">
                <div class="api-key-section">
                    <div class="settings-title">OpenAI API Key (for Pro Mode)</div>
                    <div class="settings-description">
                        Enter your OpenAI API key to enable Pro Mode with highest accuracy Whisper recognition.
                    </div>
                    <input type="password" class="api-key-input" id="apiKeyInput" placeholder="Enter your OpenAI API key here...">
                    <div style="font-size: 12px; margin-top: 4px; color: #666;">
                        This key stays on your device and is only used for speech recognition.
                    </div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Speech Recognition Mode</div>
                    <div class="settings-description">Choose your preferred speech recognition method</div>
                    <div style="margin: 12px 0;">
                        <div style="margin: 8px 0;">
                            <input type="radio" id="modeFree" name="recognitionMode" value="free" checked>
                            <label for="modeFree" style="margin-left: 8px; font-weight: bold; color: #28a745;">🆓 Free Mode (Zero Ping)</label>
                            <div style="font-size: 12px; color: #666; margin-left: 24px;">Browser-based with smart restart - no interruptions, completely free</div>
                        </div>
                        <div style="margin: 8px 0;">
                            <input type="radio" id="modePro" name="recognitionMode" value="pro">
                            <label for="modePro" style="margin-left: 8px; font-weight: bold; color: #0099cc;">🎯 Pro Mode (~$0.006/min)</label>
                            <div style="font-size: 12px; color: #666; margin-left: 24px;">OpenAI Whisper - highest accuracy for speech impairments</div>
                        </div>
                    </div>
                    <div class="setting-value" id="recognitionModeLabel">Current: Free Mode (Zero Ping)</div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Speech Playback Speed</div>
                    <div class="settings-description">How fast Leslie repeats your speech back to you</div>
                    <input type="range" class="slider" id="speechSpeedSlider" min="0.5" max="2" step="0.2" value="1.0">
                    <div class="setting-value" id="speechSpeedValue">Normal (1.0x)</div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">♿ Pause Between Words (Accessibility)</div>
                    <div class="settings-description"><strong>Critical for speech impairments:</strong> How long to wait after you stop speaking before processing. Applies to BOTH speech page AND voice commands.</div>
                    <input type="range" class="slider" id="pauseBetweenWordsSlider" min="0.5" max="6" step="0.1" value="2.0">
                    <div class="setting-value" id="pauseBetweenWordsValue">2.0 seconds</div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Speak Voice Commands</div>
                    <div class="settings-description">Whether Leslie should speak responses to voice commands</div>
                    <div class="switch">
                        <input type="checkbox" id="speakVoiceCommandsSwitch" checked>
                        <label for="speakVoiceCommandsSwitch">Enable Speak Voice Commands</label>
                    </div>
                    <div class="setting-value" id="speakVoiceCommandsLabel">Speak Voice Commands: ON</div>
                </div>
                <div class="settings-section">
                    <div class="settings-title">Zero-Ping Technology</div>
                    <div class="settings-description">Advanced settings for eliminating speech recognition interruptions</div>
                    <div style="margin: 12px 0;">
                        <div style="margin: 8px 0;">
                            <input type="checkbox" id="smartRestartSwitch" checked>
                            <label for="smartRestartSwitch" style="margin-left: 8px;">Smart Pre-emptive Restart</label>
                            <div style="font-size: 12px; color: #666; margin-left: 24px;">Restart recognition before browser timeout</div>
                        </div>
                        <div style="margin: 8px 0;">
                            <input type="checkbox" id="voiceActivitySwitch" checked>
                            <label for="voiceActivitySwitch" style="margin-left: 8px;">Voice Activity Detection</label>
                            <div style="font-size: 12px; color: #666; margin-left: 24px;">Only restart when speech is detected</div>
                        </div>
                    </div>
                </div>
            </div>
            <button class="back-btn" id="btnSettingsHome">← Back</button>
        </div>

        <!-- Weather Display -->
        <div id="weatherDisplay" class="weather-display hidden">
            <div class="weather-title" id="weatherTitle">Weather Information</div>
            <div class="weather-content" id="weatherContent">Loading weather data...</div>
            <div class="weather-controls">
                <button class="weather-btn" id="currentWeatherBtn">Current</button>
                <button class="weather-btn" id="hourlyWeatherBtn">24 Hours</button>
                <button class="weather-btn" id="weeklyWeatherBtn">7 Days</button>
                <button class="weather-btn" id="closeWeatherBtn">Close</button>
            </div>
        </div>

        <!-- Swipe Gesture Areas -->
        <div id="swipeBottom" class="swipe-edge swipe-bottom"></div>
        <div id="swipeLeft" class="swipe-edge swipe-left"></div>
        <div id="swipeRight" class="swipe-edge swipe-right"></div>

        <!-- Voice Command Status Indicator -->
        <div id="voiceCommandStatus" class="voice-command-status">🎤 Voice Commands Ready</div>
    </div>

    <script>
        // === CORE VARIABLES ===
        let speechRecognition = null;
        let commandRecognition = null;
        let speechSynth = window.speechSynthesis;
        let currentPage = 'home';
        let contacts = [];
        let filteredContacts = [];
        let userLocation = null;
        let isInitialized = false;
        let speechPageTimeout = null;
        
        // PERMISSION STATE MANAGEMENT - CRITICAL FOR PREVENTING PINGS
        let permissionState = {
            granted: false,
            denied: false,
            requesting: false,
            hasBeenRequested: false
        };
        
        // ZERO-PING STATE MANAGEMENT
        let appState = {
            speechRecognitionActive: false,
            commandRecognitionActive: false, 
            speechPageActive: false,
            userStoppedManually: false,
            phraseCount: 0,
            lastResult: '',
            lastResultTime: 0,
            isCurrentlySpeaking: false,
            processingResults: false,
            continuousRecording: false
        };
        
        // Settings with accessibility focus
        let settings = {
            speechSpeed: 1.0,
            speakVoiceCommands: true,
            apiKey: '',
            pauseBetweenWords: 2.0,  // Default longer for accessibility
            recognitionMode: 'free', // 'free' or 'pro'
            smartRestart: true,
            voiceActivity: true
        };

        // === PERMISSION MANAGEMENT - STOPS ALL PINGING ===
        async function checkMicrophonePermission() {
            console.log('🎤 Checking microphone permission...');
            
            try {
                if (permissionState.requesting) {
                    console.log('🎤 Permission request already in progress');
                    return false;
                }
                
                // Check if permission API is available
                if ('permissions' in navigator) {
                    const permission = await navigator.permissions.query({ name: 'microphone' });
                    console.log('🎤 Permission state:', permission.state);
                    
                    if (permission.state === 'granted') {
                        permissionState.granted = true;
                        permissionState.denied = false;
                        return true;
                    } else if (permission.state === 'denied') {
                        permissionState.granted = false;
                        permissionState.denied = true;
                        return false;
                    }
                }
                
                // Fallback: try to get media stream to test permission
                permissionState.requesting = true;
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { 
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false 
                    } 
                });
                
                // Permission granted
                stream.getTracks().forEach(track => track.stop()); // Clean up
                permissionState.granted = true;
                permissionState.denied = false;
                permissionState.requesting = false;
                permissionState.hasBeenRequested = true;
                
                console.log('✅ Microphone permission granted');
                return true;
                
            } catch (error) {
                permissionState.requesting = false;
                permissionState.hasBeenRequested = true;
                
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    console.log('❌ Microphone permission denied');
                    permissionState.granted = false;
                    permissionState.denied = true;
                    return false;
                } else {
                    console.log('❌ Permission check failed:', error.name);
                    return false;
                }
            }
        }

        async function requestMicrophonePermission() {
            console.log('🎤 Requesting microphone permission...');
            
            if (permissionState.requesting) {
                console.log('🎤 Permission request already in progress');
                return false;
            }
            
            updateVoiceCommandStatus('permission-needed');
            
            const hasPermission = await checkMicrophonePermission();
            
            if (hasPermission) {
                updateVoiceCommandStatus('ready');
                return true;
            } else {
                showPermissionError();
                return false;
            }
        }

        // Zero-ping management
        let speechRestartTimer = null;
        let commandRestartTimer = null;
        let speechStarting = false;
        let commandStarting = false;

        // Continuous recording (Pro Mode)
        let mediaRecorder = null;
        let audioStream = null;
        let recordingChunks = [];
        let chunkTimer = null;

        // === INITIALIZATION ===
        async function initApp() {
            console.log('🚀 Initializing Leslie Accessibility Speech Assistant...');
            
            if (isInitialized) {
                console.log('✅ Already initialized');
                return;
            }
            
            try {
                // Check browser support
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    console.error('❌ Speech recognition not supported');
                    alert('Sorry, speech recognition is not supported in this browser. Please use Chrome, Edge, or Safari.');
                    return;
                }
                
                console.log('✅ Speech Recognition supported');
                
                // Initialize components
                loadSettings();
                setupEventHandlers();
                initializeContacts();
                setupSwipeGestures();
                getUserLocation();
                updateTextSpeakButton();
                
                // Set initialization flag
                isInitialized = true;
                console.log('✅ Leslie Accessibility Assistant initialized successfully');
                
                // CRITICAL: Check permission before starting any speech recognition
                console.log('🎤 Checking microphone permission before starting...');
                const hasPermission = await checkMicrophonePermission();
                
                if (hasPermission) {
                    console.log('✅ Permission granted - starting voice commands after delay');
                    // Start command recognition with delay for accessibility - but only if permission granted
                    setTimeout(async () => {
                        try {
                            console.log('🎯 SLOWLY starting initial command recognition with permission');
                            await startZeroPingCommandRecognition();
                        } catch (error) {
                            console.error('❌ Error starting command recognition:', error);
                        }
                    }, Math.max(10000, settings.pauseBetweenWords * 3000)); // 10+ seconds minimum startup delay
                } else {
                    console.log('❌ No microphone permission - voice features will require manual activation');
                    updateVoiceCommandStatus('permission-needed');
                }
                
            } catch (error) {
                console.error('❌ Error during initialization:', error);
                alert('There was an error initializing the app. Please refresh the page.');
            }
        }

        // === ROBUST EVENT HANDLERS SETUP ===
        function setupEventHandlers() {
            console.log('🔧 Setting up ROBUST event handlers...');
            
            try {
                // Navigation buttons - EXTRA robust handling
                const navButtons = [
                    { id: 'btnStartTalking', action: () => {
                        console.log('🎤 START TALKING clicked - forcing navigation');
                        try {
                            navigateToPage('speech');
                        } catch (error) {
                            console.error('❌ Navigation failed, trying direct:', error);
                            // Force direct navigation
                            document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
                            const speechPage = document.getElementById('speechPage');
                            if (speechPage) {
                                speechPage.classList.add('active');
                                currentPage = 'speech';
                                appState.speechPageActive = true;
                                
                                // Force start recognition
                                setTimeout(() => {
                                    if (!appState.speechRecognitionActive && !speechStarting) {
                                        startSpeechRecognition();
                                    }
                                }, 1000);
                            }
                        }
                    }},
                    { id: 'btnStartTexting', action: () => navigateToPage('textInput') },
                    { id: 'btnPhoneCall', action: () => navigateToPage('phone') },
                    { id: 'btnCommands', action: () => navigateToPage('commands') },
                    { id: 'btnSettings', action: () => navigateToPage('settings') }
                ];
                
                navButtons.forEach(btn => {
                    const element = document.getElementById(btn.id);
                    if (element) {
                        // Remove any existing listeners
                        element.replaceWith(element.cloneNode(true));
                        const newElement = document.getElementById(btn.id);
                        
                        // Add multiple event listeners for reliability
                        newElement.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('🔘 Navigation button clicked:', btn.id);
                            try {
                                btn.action();
                            } catch (error) {
                                console.error('❌ Button action failed:', error);
                                alert('Button failed. Please try again.');
                            }
                        });
                        
                        // Backup touch handler for mobile
                        newElement.addEventListener('touchend', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('👆 Touch navigation:', btn.id);
                            try {
                                btn.action();
                            } catch (error) {
                                console.error('❌ Touch action failed:', error);
                            }
                        });
                    } else {
                        console.warn('⚠️ Button not found:', btn.id);
                    }
                });
                
                // Close buttons - robust handling
                const closeButtons = [
                    { id: 'btnCloseSpeech', action: () => navigateToPage('home') },
                    { id: 'btnClosePhone', action: () => navigateToPage('home') },
                    { id: 'btnCloseCommands', action: () => navigateToPage('home') },
                    { id: 'btnCloseText', action: () => navigateToPage('home') },
                    { id: 'btnCloseSettings', action: () => navigateToPage('home') }
                ];
                
                closeButtons.forEach(btn => {
                    const element = document.getElementById(btn.id);
                    if (element) {
                        element.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('❌ Close button clicked:', btn.id);
                            btn.action();
                        });
                    }
                });
                
                // Home buttons - robust handling
                const homeButtons = [
                    'btnPhoneHome', 'btnTextHome', 'btnSettingsHome', 'btnCommandsHome'
                ];
                homeButtons.forEach(btnId => {
                    const element = document.getElementById(btnId);
                    if (element) {
                        element.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('🏠 Home button clicked:', btnId);
                            navigateToPage('home');
                        });
                    }
                });
                
                // Speech page controls - EXTRA robust
                const listenButton = document.getElementById('listenButton');
                if (listenButton) {
                    listenButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎤 Listen button clicked - current state:', appState.speechRecognitionActive || appState.continuousRecording);
                        try {
                            toggleListening();
                        } catch (error) {
                            console.error('❌ Toggle listening failed:', error);
                            // Force toggle
                            if (appState.speechRecognitionActive || appState.continuousRecording) {
                                stopSpeechRecognition();
                            } else {
                                startSpeechRecognition();
                            }
                        }
                    });
                }
                
                const clearButton = document.getElementById('clearButton');
                if (clearButton) {
                    clearButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🗑️ Clear button clicked');
                        clearSpeechText();
                    });
                }

                const enhancedButton = document.getElementById('enhancedButton');
                if (enhancedButton) {
                    enhancedButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🎯 Enhanced button clicked');
                        startEnhancedRecognition();
                    });
                }
                
                // Text input functionality
                const speakTextBtn = document.getElementById('speakTextBtn');
                if (speakTextBtn) {
                    speakTextBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('🔊 Speak text button clicked');
                        speakTextInput();
                    });
                }
                
                const textInputField = document.getElementById('largeTextInputField');
                if (textInputField) {
                    textInputField.addEventListener('input', updateTextSpeakButton);
                }
                
                // Contact functionality
                const contactSearchInput = document.getElementById('contactSearchInput');
                if (contactSearchInput) {
                    contactSearchInput.addEventListener('input', (e) => {
                        filterContacts(e.target.value);
                    });
                }
                
                const loadAllBtn = document.getElementById('loadAllContactsBtn');
                const loadSelectedBtn = document.getElementById('loadSelectedContactsBtn');
                
                if (loadAllBtn) {
                    loadAllBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('📞 Load all contacts clicked');
                        loadAllContacts();
                    });
                }
                
                if (loadSelectedBtn) {
                    loadSelectedBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('📋 Load selected contacts clicked');
                        loadSelectedContacts();
                    });
                }
                
                // Weather controls
                const weatherButtons = [
                    { id: 'currentWeatherBtn', action: showCurrentWeather },
                    { id: 'hourlyWeatherBtn', action: showHourlyWeather },
                    { id: 'weeklyWeatherBtn', action: showWeeklyWeather },
                    { id: 'closeWeatherBtn', action: hideWeather }
                ];
                
                weatherButtons.forEach(btn => {
                    const element = document.getElementById(btn.id);
                    if (element) {
                        element.addEventListener('click', (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            console.log('🌤️ Weather button clicked:', btn.id);
                            btn.action();
                        });
                    }
                });
                
                // Settings event handlers
                const settingsElements = [
                    {id: 'apiKeyInput', event: 'input', handler: (e) => saveApiKey(e.target.value)},
                    {id: 'speechSpeedSlider', event: 'input', handler: (e) => updateSpeechSpeed(e.target.value)},
                    {id: 'pauseBetweenWordsSlider', event: 'input', handler: (e) => updatePauseBetweenWords(e.target.value)},
                    {id: 'speakVoiceCommandsSwitch', event: 'change', handler: (e) => updateVoiceCommandSetting(e.target.checked)},
                    {id: 'smartRestartSwitch', event: 'change', handler: (e) => { settings.smartRestart = e.target.checked; saveSettings(); }},
                    {id: 'voiceActivitySwitch', event: 'change', handler: (e) => { settings.voiceActivity = e.target.checked; saveSettings(); }}
                ];
                
                settingsElements.forEach(setting => {
                    const element = document.getElementById(setting.id);
                    if (element) {
                        element.addEventListener(setting.event, setting.handler);
                    }
                });

                // Recognition mode radio buttons
                const modeRadios = document.querySelectorAll('input[name="recognitionMode"]');
                modeRadios.forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        if (e.target.checked) {
                            console.log('🔧 Recognition mode changed to:', e.target.value);
                            updateRecognitionMode(e.target.value);
                        }
                    });
                });
                
                console.log('✅ Event handlers setup complete');
                
            } catch (error) {
                console.error('❌ Error setting up event handlers:', error);
            }
        }

        // === PAGE NAVIGATION (FIXED) ===
        function navigateToPage(pageId) {
            console.log('📄 Navigating to page:', pageId);
            
            try {
                // Force stop any sounds/recognition that might interfere
                if (speechSynth) {
                    speechSynth.cancel();
                }
                
                showPage(pageId);
            } catch (error) {
                console.error('❌ Error navigating to page:', pageId, error);
                // Try direct navigation as fallback
                try {
                    document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
                    const targetPage = document.getElementById(pageId + 'Page');
                    if (targetPage) {
                        targetPage.classList.add('active');
                        currentPage = pageId;
                        console.log('✅ Fallback navigation successful');
                    }
                } catch (fallbackError) {
                    console.error('❌ Fallback navigation failed:', fallbackError);
                    alert('Navigation error. Please try again.');
                }
            }
        }

        // === TRUE ZERO-PING BROWSER SPEECH RECOGNITION (WITH PERMISSION CHECK) ===
        function createZeroPingSpeechRecognition() {
            console.log('🎤 Creating TRUE zero-ping speech recognition...');
            
            // CRITICAL: Don't create if permission denied
            if (permissionState.denied) {
                console.log('❌ Cannot create speech recognition - permission denied');
                return false;
            }
            
            if (speechRecognition) {
                console.log('✅ Speech recognition already exists');
                return true;
            }
            
            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    console.error('❌ SpeechRecognition not available');
                    return false;
                }
                
                speechRecognition = new SpeechRecognition();
                speechRecognition.continuous = true;
                speechRecognition.interimResults = true;
                speechRecognition.lang = 'en-US';
                speechRecognition.maxAlternatives = 1;

                speechRecognition.onstart = () => {
                    console.log('🎤 ✅ SILENT speech recognition started');
                    speechStarting = false;
                    appState.speechRecognitionActive = true;
                    updateUI();
                    
                    // Much longer restart timer for accessibility - very conservative
                    if (settings.smartRestart && !permissionState.denied) {
                        speechRestartTimer = setTimeout(() => {
                            if (appState.speechRecognitionActive && appState.speechPageActive && !appState.isCurrentlySpeaking && !permissionState.denied) {
                                console.log('🔄 Conservative silent restart');
                                restartSpeechRecognitionSeamlessly();
                            }
                        }, 25000); // Much longer - 25 seconds before restart
                    }
                };

                speechRecognition.onend = () => {
                    console.log('🎤 Speech recognition ended - checking permission before restart');
                    speechStarting = false;
                    appState.speechRecognitionActive = false;
                    
                    if (speechRestartTimer) {
                        clearTimeout(speechRestartTimer);
                        speechRestartTimer = null;
                    }
                    
                    // CRITICAL: Only restart if permission is still granted
                    if (!appState.userStoppedManually && appState.speechPageActive && !appState.isCurrentlySpeaking && !permissionState.denied) {
                        setTimeout(() => {
                            if (!appState.speechRecognitionActive && !speechStarting && !permissionState.denied) {
                                console.log('🔄 SLOW silent restart (permission OK)');
                                startZeroPingSpeechRecognition();
                            }
                        }, Math.max(3000, settings.pauseBetweenWords * 1500)); // Much slower, respects accessibility timing
                    } else if (permissionState.denied) {
                        console.log('🛑 Not restarting - permission denied');
                        updateStatus('❌ Microphone permission denied - please allow access');
                    }
                    
                    updateUI();
                };

                speechRecognition.onerror = (event) => {
                    console.log('🎤 Speech recognition error (silent):', event.error);
                    speechStarting = false;
                    
                    // CRITICAL: Stop all attempts if permission denied
                    if (event.error === 'not-allowed') {
                        console.log('🛑 PERMISSION DENIED - stopping all speech recognition attempts');
                        permissionState.granted = false;
                        permissionState.denied = true;
                        appState.userStoppedManually = true; // Prevent restart attempts
                        
                        // Clear any restart timers
                        if (speechRestartTimer) {
                            clearTimeout(speechRestartTimer);
                            speechRestartTimer = null;
                        }
                        
                        showPermissionError();
                        return; // Don't attempt any retries
                    }
                    
                    // For other errors, only retry if permission is still OK
                    if (!permissionState.denied && (event.error === 'network' || event.error === 'audio-capture')) {
                        console.log('🎤 Network/audio error - will retry slowly if permission OK');
                        setTimeout(() => {
                            if (appState.speechPageActive && !appState.userStoppedManually && !permissionState.denied) {
                                startZeroPingSpeechRecognition();
                            }
                        }, Math.max(5000, settings.pauseBetweenWords * 2000));
                    }
                };

                speechRecognition.onresult = (event) => {
                    try {
                        processSpeechResults(event);
                    } catch (error) {
                        console.error('❌ Error processing speech results:', error);
                    }
                };
                
                console.log('✅ SILENT speech recognition created successfully');
                return true;
                
            } catch (error) {
                console.error('❌ Error creating speech recognition:', error);
                return false;
            }
        }

        function createZeroPingCommandRecognition() {
            console.log('🎯 Creating TRUE zero-ping command recognition...');
            
            // CRITICAL: Don't create if permission denied
            if (permissionState.denied) {
                console.log('❌ Cannot create command recognition - permission denied');
                return false;
            }
            
            if (commandRecognition) {
                console.log('✅ Command recognition already exists');
                return true;
            }
            
            try {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                if (!SpeechRecognition) {
                    console.error('❌ SpeechRecognition not available for commands');
                    return false;
                }
                
                commandRecognition = new SpeechRecognition();
                commandRecognition.continuous = true;
                commandRecognition.interimResults = false;
                commandRecognition.lang = 'en-US';
                commandRecognition.maxAlternatives = 1;

                commandRecognition.onstart = () => {
                    console.log('🎯 SILENT command recognition started');
                    commandStarting = false;
                    appState.commandRecognitionActive = true;
                    updateVoiceCommandStatus('ready');
                    
                    // Very conservative restart timer for commands
                    if (settings.smartRestart && !permissionState.denied) {
                        commandRestartTimer = setTimeout(() => {
                            if (appState.commandRecognitionActive && !appState.isCurrentlySpeaking && !permissionState.denied) {
                                console.log('🔄 Conservative silent command restart');
                                restartCommandRecognitionSeamlessly();
                            }
                        }, 45000); // Much longer - 45 seconds for commands
                    }
                };

                commandRecognition.onend = () => {
                    console.log('🎯 Command recognition ended - checking permission before restart');
                    commandStarting = false;
                    appState.commandRecognitionActive = false;
                    
                    if (commandRestartTimer) {
                        clearTimeout(commandRestartTimer);
                        commandRestartTimer = null;
                    }
                    
                    // CRITICAL: Only restart if permission is still granted
                    if (!appState.isCurrentlySpeaking && !permissionState.denied) {
                        setTimeout(() => {
                            if (!appState.commandRecognitionActive && !commandStarting && !permissionState.denied) {
                                console.log('🔄 SLOW silent command restart (permission OK)');
                                startZeroPingCommandRecognition();
                            }
                        }, Math.max(5000, settings.pauseBetweenWords * 2000)); // Much slower
                    } else if (permissionState.denied) {
                        console.log('🛑 Not restarting commands - permission denied');
                    }
                    
                    updateVoiceCommandStatus('inactive');
                };

                commandRecognition.onerror = (event) => {
                    console.log('🎯 Command recognition error (silent):', event.error);
                    commandStarting = false;
                    
                    // CRITICAL: Stop all attempts if permission denied
                    if (event.error === 'not-allowed') {
                        console.log('🛑 PERMISSION DENIED - stopping all command recognition attempts');
                        permissionState.granted = false;
                        permissionState.denied = true;
                        
                        // Clear any restart timers
                        if (commandRestartTimer) {
                            clearTimeout(commandRestartTimer);
                            commandRestartTimer = null;
                        }
                        
                        showPermissionError();
                        return; // Don't attempt any retries
                    }
                    
                    // For other errors, only retry if permission is still OK
                    if (!permissionState.denied) {
                        console.log('🎯 Command error - will retry very slowly if permission OK');
                        setTimeout(() => {
                            if (!appState.isCurrentlySpeaking && !permissionState.denied) {
                                startZeroPingCommandRecognition();
                            }
                        }, Math.max(10000, settings.pauseBetweenWords * 4000)); // Very slow retry
                    }
                };

                commandRecognition.onresult = (event) => {
                    try {
                        processCommandResults(event);
                    } catch (error) {
                        console.error('❌ Error processing command results:', error);
                    }
                };
                
                console.log('✅ SILENT command recognition created successfully');
                return true;
                
            } catch (error) {
                console.error('❌ Error creating command recognition:', error);
                return false;
            }
        }

        function restartSpeechRecognitionSeamlessly() {
            if (speechRecognition && appState.speechRecognitionActive) {
                try {
                    speechRecognition.stop();
                } catch (e) {
                    console.error('❌ Error stopping speech recognition:', e);
                }
            }
        }

        function restartCommandRecognitionSeamlessly() {
            if (commandRecognition && appState.commandRecognitionActive) {
                try {
                    commandRecognition.stop();
                } catch (e) {
                    console.error('❌ Error stopping command recognition:', e);
                }
            }
        }

        // === PRO MODE WHISPER INTEGRATION ===
        async function startProModeRecording() {
            console.log('🎯 Starting Pro Mode (Whisper) recording...');
            
            if (!settings.apiKey) {
                alert('Please enter your OpenAI API key in Settings to use Pro Mode.');
                navigateToPage('settings');
                return;
            }
            
            try {
                audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 16000
                    }
                });
                
                const mimeType = getBestMimeType();
                
                mediaRecorder = new MediaRecorder(audioStream, {
                    mimeType: mimeType,
                    audioBitsPerSecond: 64000
                });
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordingChunks.push(event.data);
                        processAudioChunkWithWhisper(event.data);
                    }
                };
                
                mediaRecorder.onstart = () => {
                    console.log('🎯 Pro Mode recording started');
                    appState.continuousRecording = true;
                    updateStatus('🎯 Pro Mode: Zero-ping Whisper recognition active');
                };
                
                mediaRecorder.onstop = () => {
                    console.log('🎯 Pro Mode recording stopped');
                    appState.continuousRecording = false;
                };
                
                mediaRecorder.start();
                
                // Process in chunks respecting pause between words
                chunkTimer = setInterval(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.requestData();
                    }
                }, Math.max(3000, settings.pauseBetweenWords * 1000)); // Respect accessibility timing
                
                resetSpeechPageTimeout();
                
            } catch (error) {
                console.error('❌ Pro Mode failed:', error);
                if (error.name === 'NotAllowedError') {
                    showPermissionError();
                } else {
                    alert('Pro Mode failed. Falling back to Free Mode.');
                    settings.recognitionMode = 'free';
                    updateRecognitionModeUI();
                    setTimeout(() => startZeroPingSpeechRecognition(), 500);
                }
            }
        }

        async function processAudioChunkWithWhisper(audioBlob) {
            if (!settings.apiKey || !audioBlob || audioBlob.size < 1000) return;
            
            try {
                const formData = new FormData();
                formData.append('file', audioBlob, 'audio.webm');
                formData.append('model', 'whisper-1');
                formData.append('language', 'en');
                formData.append('response_format', 'json');
                
                const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${settings.apiKey}`
                    },
                    body: formData
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        throw new Error('Invalid API key');
                    } else if (response.status === 429) {
                        console.log('⏸️ Rate limited, skipping chunk');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.text && result.text.trim()) {
                    handleWhisperResult(result.text.trim());
                }
                
            } catch (error) {
                console.error('❌ Whisper processing error:', error);
                if (error.message === 'Invalid API key') {
                    alert('Invalid OpenAI API key. Please check your settings.');
                    stopProModeRecording();
                    navigateToPage('settings');
                }
            }
        }

        function handleWhisperResult(text) {
            const now = Date.now();
            
            // Filter duplicates and noise
            if (text === appState.lastResult && (now - appState.lastResultTime) < 3000) {
                return;
            }
            
            // Filter noise
            const noiseWords = ['you', 'thank you', 'thanks', 'um', 'uh', 'oh'];
            if (noiseWords.includes(text.toLowerCase()) && text.split(' ').length < 3) {
                return;
            }
            
            appState.lastResult = text;
            appState.lastResultTime = now;
            
            console.log('🎯 Whisper result:', text);
            
            // Check for voice command first
            if (isVoiceCommand(text.toLowerCase())) {
                handleVoiceCommand(text.toLowerCase());
                return;
            }
            
            // Handle as speech page result
            if (appState.speechPageActive) {
                appState.phraseCount++;
                clearSpeechDisplayImmediate();
                displaySpeechResult(text);
                speakAndClearAfter(text);
                resetSpeechPageTimeout();
            }
        }

        function stopProModeRecording() {
            console.log('🛑 Stopping Pro Mode recording...');
            
            appState.continuousRecording = false;
            
            if (chunkTimer) {
                clearInterval(chunkTimer);
                chunkTimer = null;
            }
            
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                try {
                    mediaRecorder.stop();
                } catch (e) {
                    console.error('❌ Error stopping media recorder:', e);
                }
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            recordingChunks = [];
            updateUI();
        }

        function getBestMimeType() {
            const formats = [
                'audio/webm; codecs=opus',
                'audio/mp4; codecs=mp4a.40.2',
                'audio/webm',
                'audio/mp4'
            ];

            for (const format of formats) {
                if (MediaRecorder.isTypeSupported(format)) {
                    console.log('🎵 Using format:', format);
                    return format;
                }
            }
            
            return undefined;
        }

        // === UNIFIED SPEECH RECOGNITION STARTER (WITH PERMISSION CHECK) ===
        async function startSpeechRecognition() {
            console.log('🎤 Starting speech recognition in', settings.recognitionMode, 'mode...');
            
            // CRITICAL: Check permission first
            if (permissionState.denied || (!permissionState.granted && !await checkMicrophonePermission())) {
                console.log('❌ Cannot start speech recognition - no permission');
                showPermissionError();
                return;
            }
            
            try {
                if (settings.recognitionMode === 'pro') {
                    startProModeRecording();
                } else {
                    startZeroPingSpeechRecognition();
                }
            } catch (error) {
                console.error('❌ Error starting speech recognition:', error);
            }
        }

        async function startZeroPingSpeechRecognition() {
            console.log('🆓 Starting Free Mode zero-ping recognition...');
            
            if (appState.speechRecognitionActive || appState.isCurrentlySpeaking || speechStarting) {
                console.log('🎤 Speech recognition already active');
                return;
            }
            
            // CRITICAL: Check permission before attempting to start
            if (permissionState.denied) {
                console.log('❌ Cannot start - permission denied');
                showPermissionError();
                return;
            }
            
            if (!permissionState.granted && !await checkMicrophonePermission()) {
                console.log('❌ Cannot start - permission check failed');
                showPermissionError();
                return;
            }
            
            speechStarting = true;
            appState.userStoppedManually = false;
            
            if (!createZeroPingSpeechRecognition()) {
                console.error('❌ Cannot create speech recognition');
                speechStarting = false;
                return;
            }
            
            try {
                speechRecognition.start();
            } catch (error) {
                console.error('❌ Speech recognition start failed:', error);
                speechStarting = false;
                
                if (error.name === 'NotAllowedError') {
                    permissionState.denied = true;
                    permissionState.granted = false;
                    showPermissionError();
                }
            }
        }

        async function startZeroPingCommandRecognition() {
            console.log('🎯 Starting zero-ping command recognition...');
            
            if (appState.commandRecognitionActive || appState.isCurrentlySpeaking || commandStarting) {
                console.log('🎯 Command recognition already active');
                return;
            }
            
            // CRITICAL: Check permission before attempting to start
            if (permissionState.denied) {
                console.log('❌ Cannot start commands - permission denied');
                updateVoiceCommandStatus('permission-needed');
                return;
            }
            
            if (!permissionState.granted && !await checkMicrophonePermission()) {
                console.log('❌ Cannot start commands - permission check failed');
                updateVoiceCommandStatus('permission-needed');
                return;
            }
            
            commandStarting = true;
            
            if (!createZeroPingCommandRecognition()) {
                console.error('❌ Cannot create command recognition');
                commandStarting = false;
                return;
            }
            
            try {
                commandRecognition.start();
            } catch (error) {
                console.error('❌ Command recognition start failed:', error);
                commandStarting = false;
                
                if (error.name === 'NotAllowedError') {
                    permissionState.denied = true;
                    permissionState.granted = false;
                    showPermissionError();
                }
            }
        }

        function stopSpeechRecognition() {
            console.log('🛑 Stopping speech recognition...');
            
            appState.userStoppedManually = true;
            appState.speechPageActive = false;
            speechStarting = false;
            
            // Clear timers
            if (speechRestartTimer) {
                clearTimeout(speechRestartTimer);
                speechRestartTimer = null;
            }
            if (speechPageTimeout) {
                clearTimeout(speechPageTimeout);
                speechPageTimeout = null;
            }
            
            // Stop Pro Mode if active
            if (appState.continuousRecording) {
                stopProModeRecording();
            }
            
            // Stop Free Mode if active
            if (speechRecognition && appState.speechRecognitionActive) {
                try {
                    speechRecognition.stop();
                } catch (e) {
                    console.error('❌ Error stopping speech recognition:', e);
                }
            }
            
            updateUI();
        }

        function stopCommandRecognition() {
            console.log('🛑 Stopping command recognition...');
            
            commandStarting = false;
            
            if (commandRestartTimer) {
                clearTimeout(commandRestartTimer);
                commandRestartTimer = null;
            }
            
            if (commandRecognition && appState.commandRecognitionActive) {
                try {
                    commandRecognition.stop();
                } catch (e) {
                    console.error('❌ Error stopping command recognition:', e);
                }
            }
            
            updateVoiceCommandStatus('inactive');
        }

        // === RESULT PROCESSING WITH ACCESSIBILITY TIMING ===
        function processSpeechResults(event) {
            if (appState.processingResults) return;
            
            try {
                let interimText = '';
                let finalText = '';
                
                for (let i = 0; i < event.results.length; i++) {
                    const result = event.results[i];
                    if (result.isFinal) {
                        finalText += result[0].transcript;
                    } else {
                        interimText += result[0].transcript;
                    }
                }
                
                if (interimText.trim() && appState.speechPageActive) {
                    showInterim(interimText.trim());
                }
                
                if (finalText.trim()) {
                    // Apply accessibility timing
                    setTimeout(() => {
                        handleSpeechPageResult(finalText.trim());
                    }, settings.pauseBetweenWords * 500); // Half the pause setting for processing delay
                }
            } catch (error) {
                console.error('❌ Error processing speech results:', error);
            }
        }

        function processCommandResults(event) {
            try {
                let finalText = '';
                
                for (let i = 0; i < event.results.length; i++) {
                    const result = event.results[i];
                    if (result.isFinal) {
                        finalText += result[0].transcript;
                    }
                }
                
                if (finalText.trim()) {
                    // Apply accessibility timing to commands too
                    setTimeout(() => {
                        handleCommandResult(finalText.trim());
                    }, settings.pauseBetweenWords * 300); // Shorter delay for commands
                }
            } catch (error) {
                console.error('❌ Error processing command results:', error);
            }
        }

        function handleSpeechPageResult(text) {
            const now = Date.now();
            
            // Duplicate prevention with accessibility consideration
            const duplicateThreshold = Math.max(2000, settings.pauseBetweenWords * 1000);
            if (text === appState.lastResult && (now - appState.lastResultTime) < duplicateThreshold) {
                console.log('🚫 Duplicate speech result ignored:', text);
                return;
            }
            
            appState.processingResults = true;
            appState.lastResult = text;
            appState.lastResultTime = now;
            
            console.log('📝 Speech page result:', text);
            
            appState.phraseCount++;
            clearSpeechDisplayImmediate();
            displaySpeechResult(text);
            speakAndClearAfter(text);
            
            resetSpeechPageTimeout();
            
            setTimeout(() => {
                appState.processingResults = false;
            }, 1000);
        }

        function handleCommandResult(text) {
            console.log('🎯 Command result:', text);
            
            try {
                if (isVoiceCommand(text.toLowerCase())) {
                    handleVoiceCommand(text.toLowerCase());
                }
            } catch (error) {
                console.error('❌ Error handling command result:', error);
            }
        }

        function isVoiceCommand(text) {
            const triggers = ['hey leslie', 'hey lesly', 'hey lesley'];
            return triggers.some(trigger => text.includes(trigger));
        }

        // === VOICE COMMAND HANDLING (FIXED PROCESSING TIMEOUT) ===
        function handleVoiceCommand(text) {
            console.log('🎯 Processing voice command:', text);
            updateVoiceCommandStatus('processing');
            
            try {
                const command = extractCommand(text);
                console.log('📋 Extracted command:', command);
                
                if (command) {
                    // Set a timeout to ensure we don't get stuck in processing mode
                    setTimeout(() => {
                        updateVoiceCommandStatus('ready');
                    }, 3000); // Force back to ready after 3 seconds max
                    
                    executeCommand(command);
                } else {
                    console.log('❌ No command extracted');
                    updateVoiceCommandStatus('ready'); // Go back to ready immediately
                    speak('I did not understand that command');
                    restartCommandRecognitionAfterSpeaking();
                }
            } catch (error) {
                console.error('❌ Error handling voice command:', error);
                updateVoiceCommandStatus('ready'); // Go back to ready on error
                speak('Sorry, there was an error processing that command');
                restartCommandRecognitionAfterSpeaking();
            }
        }

        function extractCommand(text) {
            const triggers = ['hey leslie', 'hey lesly', 'hey lesley'];
            
            for (const trigger of triggers) {
                const index = text.indexOf(trigger);
                if (index !== -1) {
                    const command = text.substring(index + trigger.length).trim();
                    return command;
                }
            }
            
            return '';
        }

        function executeCommand(cmd) {
            console.log('⚡ Executing command:', cmd);
            
            try {
                // Update status to show command is being executed
                updateVoiceCommandStatus('processing');
                
                // Navigation commands
                if (cmd.includes('home')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    navigateToPage('home');
                    speak('Going to home page');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('start talking') || cmd.includes('talking')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    navigateToPage('speech');
                    speak('Starting speech recognition');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('start texting') || cmd.includes('texting')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    navigateToPage('textInput');
                    speak('Opening text input');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('phone') || cmd.includes('contact')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    navigateToPage('phone');
                    speak('Opening contacts');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('settings')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    navigateToPage('settings');
                    speak('Opening settings');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('help') || cmd.includes('commands')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    navigateToPage('commands');
                    speak('Showing voice commands');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                // Weather commands
                if (cmd.includes('weather') && !cmd.includes('close')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    showCurrentWeather();
                    speak('Showing current weather');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('hourly')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    showHourlyWeather();
                    speak('Showing hourly forecast');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('weekly') || cmd.includes('7 day')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    showWeeklyWeather();
                    speak('Showing weekly forecast');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('close')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    hideWeather();
                    speak('Closing weather');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                // Mode switching commands
                if (cmd.includes('free mode')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    updateRecognitionMode('free');
                    speak('Switching to free mode');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('pro mode')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    updateRecognitionMode('pro');
                    speak('Switching to pro mode');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                // Settings commands
                if (cmd.includes('speak faster')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    adjustSpeechSpeed(0.2);
                    speak('Speech speed increased');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('speak slower')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    adjustSpeechSpeed(-0.2);
                    speak('Speech speed decreased');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('pause more')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    adjustPauseBetweenWords(0.3);
                    speak('Pause between words increased');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('pause less')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    adjustPauseBetweenWords(-0.3);
                    speak('Pause between words decreased');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                if (cmd.includes('stop listening')) {
                    updateVoiceCommandStatus('ready'); // Quick status update
                    stopSpeechRecognition();
                    speak('Stopping speech recognition');
                    restartCommandRecognitionAfterSpeaking();
                    return;
                }
                
                // Unknown command
                console.log('❓ Unknown command:', cmd);
                updateVoiceCommandStatus('ready'); // Quick status update
                speak('I did not understand that command');
                restartCommandRecognitionAfterSpeaking();
                
            } catch (error) {
                console.error('❌ Error executing command:', error);
                updateVoiceCommandStatus('ready'); // Reset status on error
                speak('Sorry, there was an error executing that command');
                restartCommandRecognitionAfterSpeaking();
            }
        }

        function restartCommandRecognitionAfterSpeaking() {
            // MUCH longer restart after voice commands to completely prevent ping sounds
            setTimeout(() => {
                if (!appState.isCurrentlySpeaking && !appState.commandRecognitionActive && !commandStarting) {
                    console.log('🔄 VERY SLOW restart of command recognition after command execution');
                    startZeroPingCommandRecognition();
                }
            }, Math.max(15000, settings.pauseBetweenWords * 5000)); // 15+ seconds minimum to prevent all pings
        }

        // === SPEECH PAGE TIMEOUT (FIXED TO 2 MINUTES) ===
        function resetSpeechPageTimeout() {
            if (speechPageTimeout) {
                clearTimeout(speechPageTimeout);
            }
            
            if (appState.speechPageActive) {
                console.log('⏱️ Setting 2-minute speech timeout');
                // Exactly 2 minutes as requested
                speechPageTimeout = setTimeout(() => {
                    console.log('⏱️ 2-minute speech timeout reached');
                    stopSpeechRecognition();
                    updateStatus('⏱️ 2-minute timeout reached - click START to resume');
                    
                    const textEl = document.getElementById('recognizedText');
                    if (textEl) {
                        textEl.innerHTML = `<div style="color: #ff6600; font-weight: bold; text-align: center; padding: 20px;">⏱️ Session timed out after 2 minutes of no speech<br><br>Click "START" button to resume listening</div>`;
                    }
                }, 120000); // Exactly 2 minutes = 120,000 milliseconds
            }
        }

        function showInterim(text) {
            try {
                const textEl = document.getElementById('recognizedText');
                if (!textEl) return;
                
                let content = textEl.innerHTML.replace(/<div class="interim"[^>]*>.*?<\/div>/s, '');
                content += `<div class="interim" style="background: #fff8e1; padding: 8px; border-radius: 4px; margin: 4px 0; color: #666; font-style: italic;">🎤 Speaking: "${text}"</div>`;
                
                textEl.innerHTML = content;
                textEl.scrollTop = textEl.scrollHeight;
            } catch (error) {
                console.error('❌ Error showing interim text:', error);
            }
        }

        function displaySpeechResult(text) {
            try {
                const textEl = document.getElementById('recognizedText');
                if (!textEl) return;
                
                const modeIndicator = settings.recognitionMode === 'pro' ? '🎯 PRO' : '🆓 FREE';
                const result = `<div style="background: #e8f5e8; padding: 12px; border-radius: 6px; margin: 8px 0; border-left: 4px solid #28a745; font-weight: bold;">✅ ${modeIndicator} Phrase ${appState.phraseCount}: "${text}"</div>`;
                
                textEl.innerHTML = result;
                textEl.scrollTop = textEl.scrollHeight;
            } catch (error) {
                console.error('❌ Error displaying speech result:', error);
            }
        }

        function clearSpeechDisplayImmediate() {
            try {
                const textEl = document.getElementById('recognizedText');
                if (textEl && appState.speechPageActive) {
                    textEl.innerHTML = '';
                }
            } catch (error) {
                console.error('❌ Error clearing speech display:', error);
            }
        }

        // === SPEECH SYNTHESIS WITH ACCESSIBILITY ===
        function speak(text) {
            if (!settings.speakVoiceCommands) return;
            
            console.log('🔊 Speaking:', text);
            
            try {
                speechSynth.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = settings.speechSpeed || 1.0;
                utterance.lang = 'en-US';
                
                utterance.onstart = () => {
                    appState.isCurrentlySpeaking = true;
                    updateVoiceCommandStatus('speaking');
                    if (appState.speechPageActive) {
                        updateStatus('🔊 Speaking: "' + text + '"');
                    }
                };
                
                utterance.onend = () => {
                    appState.isCurrentlySpeaking = false;
                    console.log('🔊 Finished speaking');
                    
                    setTimeout(() => {
                        if (!appState.isCurrentlySpeaking) {
                            updateVoiceCommandStatus('ready');
                        }
                    }, settings.pauseBetweenWords * 100); // Small delay respecting pause setting
                };
                
                speechSynth.speak(utterance);
            } catch (error) {
                console.error('❌ Error speaking text:', error);
                appState.isCurrentlySpeaking = false;
            }
        }

        function speakAndClearAfter(text) {
            console.log('🔊 Speaking and will clear:', text);
            
            try {
                speechSynth.cancel();
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = settings.speechSpeed || 1.0;
                utterance.lang = 'en-US';
                
                utterance.onstart = () => {
                    appState.isCurrentlySpeaking = true;
                    updateVoiceCommandStatus('speaking');
                    updateStatus('🔊 Speaking: "' + text + '"');
                };
                
                utterance.onend = () => {
                    appState.isCurrentlySpeaking = false;
                    console.log('🔊 Finished speaking, clearing screen');
                    
                    setTimeout(() => {
                        clearSpeechDisplay();
                        const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                        updateStatus(`🎤 ${modeLabel} ready for your next phrase...`);
                        updateVoiceCommandStatus('ready');
                    }, Math.max(500, settings.pauseBetweenWords * 200)); // Respect accessibility timing
                };
                
                speechSynth.speak(utterance);
            } catch (error) {
                console.error('❌ Error speaking and clearing text:', error);
                appState.isCurrentlySpeaking = false;
            }
        }

        function clearSpeechDisplay() {
            try {
                const textEl = document.getElementById('recognizedText');
                if (textEl && appState.speechPageActive) {
                    const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                    textEl.innerHTML = `<div style="color: #0099cc; font-style: italic; text-align: center; padding: 20px;">🎤 ${modeLabel} ready for your next phrase...</div>`;
                }
            } catch (error) {
                console.error('❌ Error clearing speech display:', error);
            }
        }

        // === PAGE MANAGEMENT ===
        function showPage(pageId) {
            console.log('📄 Showing page:', pageId);
            
            try {
                // Clear all timers
                if (speechPageTimeout) {
                    clearTimeout(speechPageTimeout);
                    speechPageTimeout = null;
                }
                if (speechRestartTimer) {
                    clearTimeout(speechRestartTimer);
                    speechRestartTimer = null;
                }
                if (commandRestartTimer) {
                    clearTimeout(commandRestartTimer);
                    commandRestartTimer = null;
                }
                
                // Update page state
                const wasOnSpeechPage = appState.speechPageActive;
                appState.speechPageActive = (pageId === 'speech');
                
                // Stop speech recognition if leaving speech page
                if (wasOnSpeechPage && pageId !== 'speech') {
                    if (speechRecognition && appState.speechRecognitionActive) {
                        appState.userStoppedManually = true;
                        speechStarting = false;
                        try {
                            speechRecognition.stop();
                        } catch (e) {
                            console.error('❌ Error stopping speech recognition:', e);
                        }
                    }
                    
                    if (appState.continuousRecording) {
                        stopProModeRecording();
                    }
                }
                
                // Show the page
                document.querySelectorAll('.page').forEach(page => {
                    page.classList.remove('active');
                });
                
                const targetPage = document.getElementById(pageId + 'Page');
                if (targetPage) {
                    targetPage.classList.add('active');
                    currentPage = pageId;
                    
                    if (pageId === 'speech') {
                        console.log('🎤 ACTIVATING SPEECH PAGE - AUTO-LISTENING MODE');
                        
                        // Reset state for speech page
                        appState.phraseCount = 0;
                        appState.userStoppedManually = false;
                        speechStarting = false;
                        
                        // Set initial display
                        const textEl = document.getElementById('recognizedText');
                        if (textEl) {
                            const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                            textEl.innerHTML = `<div style="color: #0099cc; font-weight: bold; text-align: center; padding: 20px;">🎤 ${modeLabel} checking permissions...</div>`;
                        }
                        
                        // Check permission before starting
                        setTimeout(async () => {
                            if (!appState.speechPageActive) return; // User might have navigated away
                            
                            console.log('🎤 Checking permission for speech page');
                            const hasPermission = await checkMicrophonePermission();
                            
                            if (hasPermission && appState.speechPageActive) {
                                if (textEl) {
                                    const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                                    textEl.innerHTML = `<div style="color: #0099cc; font-weight: bold; text-align: center; padding: 20px;">🎤 ${modeLabel} starting auto-listening...</div>`;
                                }
                                
                                // Start listening with permission confirmed
                                if (!appState.speechRecognitionActive && !appState.isCurrentlySpeaking && 
                                    !speechStarting && !appState.continuousRecording) {
                                    console.log('🚀 AUTO-STARTING speech recognition (permission confirmed)');
                                    await startSpeechRecognition();
                                    
                                    // Update display to show it's listening
                                    setTimeout(() => {
                                        if (appState.speechPageActive && textEl) {
                                            const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                                            textEl.innerHTML = `<div style="color: #28a745; font-weight: bold; text-align: center; padding: 20px;">🎤 ${modeLabel} LISTENING - Speak now!</div>`;
                                        }
                                        resetSpeechPageTimeout(); // 2 minute timeout as requested
                                    }, 1000);
                                }
                            } else {
                                // No permission
                                if (textEl) {
                                    textEl.innerHTML = `<div style="color: #cc0000; font-weight: bold; text-align: center; padding: 20px;">❌ Microphone permission needed<br><br>Click "START" to grant permission</div>`;
                                }
                                updateStatus('❌ Microphone permission needed - click START button');
                                updateVoiceCommandStatus('permission-needed');
                            }
                        }, 1000);
                        
                        // Start command recognition separately if permission allows
                        setTimeout(async () => {
                            if (appState.speechPageActive && !appState.commandRecognitionActive && 
                                !appState.isCurrentlySpeaking && !commandStarting && !permissionState.denied) {
                                console.log('🎯 SLOWLY starting command recognition on speech page');
                                await startZeroPingCommandRecognition();
                            }
                        }, Math.max(8000, settings.pauseBetweenWords * 2000));
                    } else {
                        // On other pages, slower command recognition startup
                        setTimeout(async () => {
                            if (!appState.commandRecognitionActive && !appState.isCurrentlySpeaking && 
                                !commandStarting && !permissionState.denied) {
                                console.log('🎯 SLOWLY starting command recognition for other page');
                                await startZeroPingCommandRecognition();
                            }
                        }, Math.max(5000, settings.pauseBetweenWords * 1500));
                    }
                    
                    if (pageId === 'phone') {
                        displayContactsOnPhonePage();
                    }
                    
                    if (pageId === 'textInput') {
                        setTimeout(() => {
                            const textField = document.getElementById('largeTextInputField');
                            if (textField) textField.focus();
                        }, 300);
                    }
                } else {
                    console.error('❌ Target page not found:', pageId + 'Page');
                }
                
                updateUI();
                
            } catch (error) {
                console.error('❌ Error showing page:', error);
            }
        }

        function toggleListening() {
            try {
                if (appState.speechRecognitionActive || appState.continuousRecording) {
                    stopSpeechRecognition();
                } else {
                    appState.userStoppedManually = false;
                    startSpeechRecognition();
                    resetSpeechPageTimeout();
                }
            } catch (error) {
                console.error('❌ Error toggling listening:', error);
            }
        }

        function clearSpeechText() {
            try {
                appState.phraseCount = 0;
                const textEl = document.getElementById('recognizedText');
                if (textEl) {
                    const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                    if (appState.speechRecognitionActive || appState.continuousRecording) {
                        textEl.innerHTML = `<div style="color: #0099cc; font-style: italic; text-align: center; padding: 20px;">🎤 ${modeLabel} ready for your next phrase...</div>`;
                    } else {
                        textEl.innerHTML = `<div style="color: #666; font-style: italic; text-align: center; padding: 20px;">Ready for ${modeLabel} recognition...</div>`;
                    }
                }
            } catch (error) {
                console.error('❌ Error clearing speech text:', error);
            }
        }

        // === UI UPDATES ===
        function updateUI() {
            try {
                updateListenButton();
                updateStatus();
            } catch (error) {
                console.error('❌ Error updating UI:', error);
            }
        }

        function updateListenButton() {
            try {
                const button = document.getElementById('listenButton');
                if (button) {
                    if (appState.speechRecognitionActive || appState.continuousRecording) {
                        button.textContent = 'STOP LISTENING';
                        button.className = 'control-btn btn-stop';
                    } else {
                        const modeLabel = settings.recognitionMode === 'pro' ? 'PRO' : 'FREE';
                        button.textContent = `START ${modeLabel} MODE`;
                        button.className = 'control-btn btn-listen';
                    }
                }
            } catch (error) {
                console.error('❌ Error updating listen button:', error);
            }
        }

        function updateStatus(message = null) {
            try {
                const statusEl = document.getElementById('statusText');
                if (statusEl && message) {
                    statusEl.textContent = message;
                } else if (statusEl && appState.speechPageActive) {
                    if (appState.isCurrentlySpeaking) {
                        statusEl.textContent = '🔊 Speaking - Recognition paused';
                    } else if (appState.speechRecognitionActive || appState.continuousRecording) {
                        const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                        statusEl.textContent = `🎤 ${modeLabel}: Zero-ping continuous listening`;
                    } else {
                        const modeLabel = settings.recognitionMode === 'pro' ? 'Pro Mode' : 'Free Mode';
                        statusEl.textContent = `🛑 Click "START ${modeLabel.toUpperCase()}" to begin`;
                    }
                }
            } catch (error) {
                console.error('❌ Error updating status:', error);
            }
        }

        function updateVoiceCommandStatus(status = null) {
            try {
                const statusEl = document.getElementById('voiceCommandStatus');
                if (!statusEl) return;
                
                statusEl.className = 'voice-command-status';
                
                let currentStatus = status;
                if (!currentStatus) {
                    if (appState.isCurrentlySpeaking) {
                        currentStatus = 'speaking';
                    } else if (appState.commandRecognitionActive) {
                        currentStatus = 'ready';
                    } else {
                        currentStatus = 'inactive';
                    }
                }
                
                switch (currentStatus) {
                    case 'ready':
                        statusEl.classList.add('ready');
                        statusEl.textContent = '🟢 "Hey Leslie" Ready';
                        statusEl.style.display = 'block';
                        statusEl.onclick = null;
                        break;
                    case 'processing':
                        statusEl.classList.add('processing');
                        statusEl.textContent = '🟡 Processing Command...';
                        statusEl.style.display = 'block';
                        statusEl.onclick = null;
                        break;
                    case 'speaking':
                        statusEl.classList.add('speaking');
                        statusEl.textContent = '🟣 Speaking...';
                        statusEl.style.display = 'block';
                        statusEl.onclick = null;
                        break;
                    case 'permission-needed':
                        statusEl.classList.add('permission-needed');
                        statusEl.textContent = '🔴 Click to Allow Microphone';
                        statusEl.style.display = 'block';
                        statusEl.onclick = requestPermission;
                        break;
                    default:
                        statusEl.textContent = '⚫ Voice Commands Off';
                        statusEl.style.display = 'block';
                        statusEl.style.background = 'rgba(128, 128, 128, 0.9)';
                        statusEl.style.color = 'white';
                        statusEl.onclick = null;
                }
            } catch (error) {
                console.error('❌ Error updating voice command status:', error);
            }
        }

        function showPermissionError() {
            updateVoiceCommandStatus('permission-needed');
            updateStatus('🔴 Microphone permission needed');
            
            // Show permission instructions
            const statusEl = document.getElementById('statusText');
            if (statusEl && appState.speechPageActive) {
                statusEl.innerHTML = `<div style="color: #cc0000; text-align: center; font-weight: bold;">
                    🎤 MICROPHONE ACCESS NEEDED<br><br>
                    Click the "START" button below to grant permission<br>
                    Then allow microphone access when prompted
                </div>`;
            }
        }

        async function requestPermission() {
            console.log('🎤 User requested microphone permission');
            
            try {
                const hasPermission = await checkMicrophonePermission();
                
                if (hasPermission) {
                    console.log('✅ Permission granted - starting speech systems');
                    appState.userStoppedManually = false;
                    
                    // Start command recognition first
                    await startZeroPingCommandRecognition();
                    
                    // If on speech page, start speech recognition too
                    if (appState.speechPageActive) {
                        await startSpeechRecognition();
                        resetSpeechPageTimeout();
                    }
                } else {
                    console.log('❌ Permission still denied');
                    showPermissionError();
                }
            } catch (error) {
                console.error('❌ Error requesting permission:', error);
                showPermissionError();
            }
        }

        // === TEXT INPUT ===
        function speakTextInput() {
            try {
                const textField = document.getElementById('largeTextInputField');
                if (textField && textField.value.trim()) {
                    speak(textField.value.trim());
                    textField.value = '';
                    updateTextSpeakButton();
                }
            } catch (error) {
                console.error('❌ Error speaking text input:', error);
            }
        }

        function updateTextSpeakButton() {
            try {
                const speakBtn = document.getElementById('speakTextBtn');
                const textField = document.getElementById('largeTextInputField');
                
                if (speakBtn && textField) {
                    if (textField.value.trim()) {
                        speakBtn.disabled = false;
                        speakBtn.style.opacity = '1';
                        speakBtn.style.backgroundColor = '#9933cc';
                    } else {
                        speakBtn.disabled = true;
                        speakBtn.style.opacity = '0.5';
                        speakBtn.style.backgroundColor = '#ccc';
                    }
                }
            } catch (error) {
                console.error('❌ Error updating text speak button:', error);
            }
        }

        // === CONTACTS ===
        function initializeContacts() {
            try {
                contacts = [
                    { name: 'Emergency Services', phone: '911' },
                    { name: 'Demo Contact 1', phone: '(555) 123-4567' },
                    { name: 'Demo Contact 2', phone: '(555) 987-6543' },
                    { name: 'Demo Contact 3', phone: '(555) 246-8135' }
                ];
                filteredContacts = contacts.slice();
                console.log('✅ Demo contacts initialized');
            } catch (error) {
                console.error('❌ Error initializing contacts:', error);
            }
        }

        async function loadAllContacts() {
            try {
                const contactsList = document.getElementById('contactsList');
                const loadingSection = document.getElementById('contactLoadingSection');
                
                if (loadingSection) loadingSection.style.display = 'none';
                
                if (contactsList) {
                    contactsList.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #669900; background: #f0f8ff; border-radius: 8px; border: 2px solid #669900;">
                            <p><strong>📞 LOADING ALL CONTACTS</strong></p>
                            <p style="margin: 10px 0;">Opening contact picker...</p>
                        </div>
                    `;
                }
                
                if ('contacts' in navigator && 'ContactsManager' in window) {
                    const props = ['name', 'tel'];
                    const opts = { multiple: true };
                    const contactList = await navigator.contacts.select(props, opts);
                    
                    if (contactList && contactList.length > 0) {
                        const processedContacts = [];
                        contactList.forEach(contact => {
                            const names = contact.name || ['Unknown Contact'];
                            const phones = contact.tel || [];
                            const contactName = names[0] || 'Unknown Contact';
                            
                            if (phones.length > 0) {
                                phones.forEach((phone, phoneIndex) => {
                                    processedContacts.push({
                                        name: phones.length > 1 ? `${contactName} (${phoneIndex + 1})` : contactName,
                                        phone: phone
                                    });
                                });
                            } else {
                                processedContacts.push({
                                    name: contactName,
                                    phone: 'No phone number'
                                });
                            }
                        });
                        
                        const uniqueContacts = processedContacts.filter((contact, index, self) =>
                            index === self.findIndex(c => 
                                c.name === contact.name && c.phone === contact.phone
                            )
                        );
                        
                        contacts = uniqueContacts.sort((a, b) => a.name.localeCompare(b.name));
                        filteredContacts = contacts.slice();
                        displayRealContactsOnPhonePage();
                    } else {
                        throw new Error('No contacts selected');
                    }
                } else {
                    throw new Error('Contacts API not supported on this device/browser');
                }
            } catch (error) {
                console.error('❌ Error loading all contacts:', error);
                handleContactLoadingError(error, document.getElementById('contactsList'));
            }
        }

        async function loadSelectedContacts() {
            try {
                const contactsList = document.getElementById('contactsList');
                const loadingSection = document.getElementById('contactLoadingSection');
                
                if (loadingSection) loadingSection.style.display = 'none';
                
                if (contactsList) {
                    contactsList.innerHTML = `
                        <div style="padding: 16px; text-align: center; color: #0099cc; background: #f0f8ff; border-radius: 8px;">
                            <p><strong>📋 Choose Specific Contacts</strong></p>
                            <p>⏳ Opening contact picker...</p>
                        </div>
                    `;
                }
                
                if ('contacts' in navigator && 'ContactsManager' in window) {
                    const props = ['name', 'tel'];
                    const opts = { multiple: true };
                    const contactList = await navigator.contacts.select(props, opts);
                    
                    if (contactList.length > 0) {
                        const processedContacts = contactList.map(contact => {
                            const name = (contact.name && contact.name[0]) ? contact.name[0] : 'Unknown';  
                            const phone = (contact.tel && contact.tel[0]) ? contact.tel[0] : 'No phone';
                            return { name, phone };
                        });
                        
                        const uniqueContacts = processedContacts.filter((contact, index, self) => 
                            index === self.findIndex(c => c.name === contact.name && c.phone === contact.phone)
                        );
                        
                        contacts = uniqueContacts.sort((a, b) => a.name.localeCompare(b.name));
                        filteredContacts = contacts.slice();
                        displayRealContactsOnPhonePage();
                    } else {
                        if (contactsList) {
                            contactsList.innerHTML = `
                                <div style="padding: 20px; text-align: center; color: #ff6600; border: 2px solid #ff6600; border-radius: 8px;">
                                    <p><strong>📱 No Contacts Selected</strong></p>
                                    <p>Demo contacts remain available</p>
                                </div>
                            `;
                        }
                        setTimeout(() => displayContactsOnPhonePage(), 3000);
                    }
                } else {
                    throw new Error('Contacts API not supported on this device/browser');
                }
            } catch (error) {
                console.error('❌ Error loading selected contacts:', error);
                handleContactLoadingError(error, document.getElementById('contactsList'));
            }
        }

        function handleContactLoadingError(error, contactsList) {
            try {
                let errorMessage = '';
                if (error.name === 'NotAllowedError') {
                    errorMessage = `<p><strong>📱 Permission Denied</strong></p><p>You denied contact access</p>`;
                } else if (error.name === 'AbortError') {
                    errorMessage = `<p><strong>📱 Contact Selection Cancelled</strong></p>`;
                } else if (error.message.includes('not supported')) {
                    errorMessage = `<p><strong>📱 Contacts API Not Supported</strong></p><p>Requires Chrome Android or Safari iOS</p>`;
                } else {
                    errorMessage = `<p><strong>📱 Contact Loading Error</strong></p><p>${error.message || 'Unknown error'}</p>`;
                }
                
                if (contactsList) {
                    contactsList.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #cc0000; border: 2px solid #cc0000; border-radius: 8px;">
                            ${errorMessage}
                            <p style="margin-top: 15px;">Demo contacts will remain available</p>
                        </div>
                    `;
                }
                
                setTimeout(() => displayContactsOnPhonePage(), 4000);
            } catch (displayError) {
                console.error('❌ Error handling contact loading error:', displayError);
            }
        }

        function displayRealContactsOnPhonePage() {
            try {
                const contactsList = document.getElementById('contactsList');
                if (!contactsList) return;
                
                contactsList.innerHTML = '';

                const successHeader = document.createElement('div');
                successHeader.style.cssText = 'padding: 12px; text-align: center; font-weight: bold; color: white; background: #28a745; border-radius: 8px; margin-bottom: 8px;';
                successHeader.innerHTML = `✅ SUCCESS: ${filteredContacts.length} REAL contacts loaded!`;
                contactsList.appendChild(successHeader);

                filteredContacts.forEach((contact) => {
                    const contactEl = document.createElement('div');
                    contactEl.className = 'contact-item';
                    contactEl.style.backgroundColor = '#e8f5e8';
                    contactEl.innerHTML = `<div class="contact-name">${contact.name}</div><div class="contact-phone">${contact.phone}</div>`;
                    contactEl.addEventListener('click', () => callContact(contact));
                    contactsList.appendChild(contactEl);
                });

                const footerNote = document.createElement('div');
                footerNote.style.cssText = 'padding: 8px; text-align: center; font-size: 12px; color: #28a745; font-weight: bold; margin-top: 8px;';
                footerNote.textContent = '📱 These are YOUR real contacts - searchable and callable!';
                contactsList.appendChild(footerNote);
            } catch (error) {
                console.error('❌ Error displaying real contacts:', error);
            }
        }

        function displayContactsOnPhonePage() {
            try {
                const contactsList = document.getElementById('contactsList');
                if (!contactsList) return;
                
                contactsList.innerHTML = '';
                
                if (filteredContacts.length === 0) {
                    contactsList.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;"><p><strong>📱 No contacts found</strong></p></div>';
                    return;
                }

                const headerDiv = document.createElement('div');
                headerDiv.style.cssText = 'padding: 12px; text-align: center; font-weight: bold; color: #669900; background: #f0f8ff; border-radius: 8px; margin-bottom: 8px;';
                headerDiv.textContent = `📱 ${filteredContacts.length} contacts available - Tap any contact to call`;
                contactsList.appendChild(headerDiv);

                filteredContacts.forEach((contact) => {
                    const contactEl = document.createElement('div');
                    contactEl.className = 'contact-item';
                    contactEl.innerHTML = `<div class="contact-name">${contact.name}</div><div class="contact-phone">${contact.phone}</div>`;
                    contactEl.addEventListener('click', () => callContact(contact));
                    contactsList.appendChild(contactEl);
                });
            } catch (error) {
                console.error('❌ Error displaying contacts:', error);
            }
        }

        function filterContacts(searchTerm) {
            try {
                if (!searchTerm.trim()) {
                    filteredContacts = contacts.slice();
                } else {
                    const searchLower = searchTerm.toLowerCase().trim();
                    filteredContacts = contacts.filter(contact => {
                        return contact.name.toLowerCase().includes(searchLower) ||
                               contact.phone.replace(/[^0-9]/g, '').includes(searchTerm.replace(/[^0-9]/g, ''));
                    });
                }
                displayContactsOnPhonePage();
            } catch (error) {
                console.error('❌ Error filtering contacts:', error);
            }
        }

        function callContact(contact) {
            try {
                const phoneNumber = contact.phone.replace(/[^0-9]/g, '');
                if (phoneNumber) {
                    window.location.href = `tel:${phoneNumber}`;
                }
            } catch (error) {
                console.error('❌ Error calling contact:', error);
            }
        }

        // === WEATHER ===
        function getUserLocation() {
            userLocation = { lat: 38.8117, lon: -90.8529 }; // Wentzville, MO
            console.log('📍 Using default location');
        }

        async function showCurrentWeather() {
            try {
                showWeatherDisplay('Current Weather', 'Loading current weather...');
                
                const { lat, lon } = userLocation || { lat: 40.7128, lon: -74.0060 };
                
                const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,wind_speed_10m,weather_code&timezone=auto`);
                const weatherData = await weatherResponse.json();
                
                let cityName = 'Your Location';
                try {
                    const locationResponse = await fetch(`https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=en`);
                    const locationData = await locationResponse.json();
                    
                    if (locationData.city) {
                        cityName = locationData.city;
                    } else if (locationData.locality) {
                        cityName = locationData.locality;
                    }
                } catch (locationError) {
                    console.log('Could not get location name:', locationError);
                }
                
                const temperature = Math.round(weatherData.current.temperature_2m * 9/5 + 32);
                const humidity = weatherData.current.relative_humidity_2m;
                const windSpeed = Math.round(weatherData.current.wind_speed_10m * 0.621371);
                const conditions = getWeatherDescription(weatherData.current.weather_code);
                
                const weatherContent = `
                    <div style="text-align: center; padding: 10px;">
                        <div style="font-size: 16px; font-weight: bold; color: #0099cc; margin-bottom: 8px;">📍 ${cityName}</div>
                        <div style="font-size: 28px; font-weight: bold; color: #0099cc; margin-bottom: 8px;">${temperature}°F</div>
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 16px;">${conditions}</div>
                        <div style="font-size: 14px; line-height: 1.6;">
                            <div><strong>Humidity:</strong> ${humidity}%</div>
                            <div><strong>Wind:</strong> ${windSpeed} mph</div>
                        </div>
                    </div>
                `;
                
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = weatherContent;
            } catch (error) {
                console.error('❌ Weather error:', error);
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = '<div style="text-align: center; padding: 20px;">Unable to load weather data.</div>';
            }
        }

        async function showHourlyWeather() {
            try {
                showWeatherDisplay('Next 24 Hours', 'Loading 24-hour forecast...');
                
                const { lat, lon } = userLocation || { lat: 38.8117, lon: -90.8529 };
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=temperature_2m,weather_code&timezone=auto&forecast_days=2`);
                const data = await response.json();
                
                const now = new Date();
                const currentHour = now.getHours();
                
                let hourlyData = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(90px, 1fr)); gap: 4px; padding: 10px; max-height: 400px; overflow-y: auto;">';
                
                let startIndex = 0;
                for (let i = 0; i < data.hourly.time.length; i++) {
                    const timeDate = new Date(data.hourly.time[i]);
                    if (timeDate.getHours() === currentHour && 
                        timeDate.getDate() === now.getDate()) {
                        startIndex = i;
                        break;
                    }
                }
                
                for (let i = startIndex; i < Math.min(startIndex + 24, data.hourly.time.length); i++) {
                    const time = new Date(data.hourly.time[i]);
                    const hour = time.getHours();
                    const temp = Math.round(data.hourly.temperature_2m[i] * 9/5 + 32);
                    const weatherCode = data.hourly.weather_code[i];
                    const conditions = getWeatherDescription(weatherCode);
                    
                    const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
                    const ampm = hour >= 12 ? 'PM' : 'AM';
                    
                    const isCurrent = i === startIndex;
                    const timeDisplay = isCurrent ? 'NOW' : `${displayHour}${ampm}`;
                    const bgColor = isCurrent ? '#0099cc' : '#f0f8ff';
                    const textColor = isCurrent ? 'white' : 'black';
                    
                    hourlyData += `
                        <div class="hourly-item" style="background-color: ${bgColor}; color: ${textColor}; padding: 6px; text-align: center; font-size: 10px; border-radius: 4px;">
                            <div style="font-weight: bold; font-size: 11px;">${timeDisplay}</div>
                            <div style="font-size: 12px; font-weight: bold; margin: 2px 0;">${temp}°</div>
                            <div style="font-size: 9px; opacity: 0.9; line-height: 1.1;">${conditions}</div>
                        </div>
                    `;
                }
                hourlyData += '</div>';
                
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = hourlyData;
            } catch (error) {
                console.error('❌ Hourly weather error:', error);
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = '<div style="text-align: center; padding: 20px;">Unable to load 24-hour forecast.</div>';
            }
        }

        async function showWeeklyWeather() {
            try {
                showWeatherDisplay('7-Day Forecast', 'Loading 7-day forecast...');
                
                const { lat, lon } = userLocation || { lat: 40.7128, lon: -74.0060 };
                const response = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_max,temperature_2m_min,weather_code&timezone=auto&forecast_days=7`);
                const data = await response.json();
                
                const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                let weeklyData = '<div style="display: grid; gap: 6px; padding: 10px;">';
                
                for (let i = 0; i < Math.min(7, data.daily.time.length); i++) {
                    const date = new Date(data.daily.time[i]);
                    const dayName = days[date.getDay()];
                    const high = Math.round(data.daily.temperature_2m_max[i] * 9/5 + 32);
                    const low = Math.round(data.daily.temperature_2m_min[i] * 9/5 + 32);
                    const conditions = getWeatherDescription(data.daily.weather_code[i]);
                    
                    weeklyData += `
                        <div class="weekly-item">
                            <div class="day-name">${dayName}</div>
                            <div class="day-temps">${high}°/${low}°</div>
                            <div class="day-condition">${conditions}</div>
                        </div>
                    `;
                }
                weeklyData += '</div>';
                
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = weeklyData;
            } catch (error) {
                console.error('❌ Weekly weather error:', error);
                const weatherContentEl = document.getElementById('weatherContent');
                if (weatherContentEl) weatherContentEl.innerHTML = '<div style="text-align: center; padding: 20px;">Unable to load 7-day forecast.</div>';
            }
        }

        function showWeatherDisplay(title, content) {
            try {
                const weatherDisplay = document.getElementById('weatherDisplay');
                const weatherTitle = document.getElementById('weatherTitle');
                const weatherContent = document.getElementById('weatherContent');
                
                if (weatherTitle) weatherTitle.textContent = title;
                if (weatherContent) weatherContent.innerHTML = `<div style="text-align: center; padding: 20px;">${content}</div>`;
                if (weatherDisplay) weatherDisplay.classList.remove('hidden');
            } catch (error) {
                console.error('❌ Error showing weather display:', error);
            }
        }

        function hideWeather() {
            try {
                const weatherDisplay = document.getElementById('weatherDisplay');
                if (weatherDisplay) {
                    weatherDisplay.classList.add('hidden');
                    console.log('✅ Weather display hidden');
                }
            } catch (error) {
                console.error('❌ Error hiding weather:', error);
            }
        }

        function getWeatherDescription(code) {
            const weatherCodes = {
                0: 'Clear sky', 1: 'Mainly clear', 2: 'Partly cloudy', 3: 'Overcast',
                45: 'Fog', 48: 'Depositing rime fog',
                51: 'Light drizzle', 53: 'Moderate drizzle', 55: 'Dense drizzle',
                61: 'Slight rain', 63: 'Moderate rain', 65: 'Heavy rain',
                71: 'Slight snow', 73: 'Moderate snow', 75: 'Heavy snow',
                80: 'Slight rain showers', 81: 'Moderate rain showers', 82: 'Violent rain showers',
                95: 'Thunderstorm', 96: 'Thunderstorm with hail', 99: 'Thunderstorm with heavy hail'
            };
            return weatherCodes[code] || 'Unknown';
        }

        // === SWIPE GESTURES ===
        function setupSwipeGestures() {
            try {
                const swipeBottom = document.getElementById('swipeBottom');
                const swipeLeft = document.getElementById('swipeLeft');
                const swipeRight = document.getElementById('swipeRight');
                
                let touchStartX = 0;
                let touchStartY = 0;
                const minSwipeDistance = 50;

                if (swipeBottom) {
                    swipeBottom.addEventListener('touchstart', function(e) {
                        touchStartY = e.changedTouches[0].clientY;
                        e.preventDefault();
                    }, { passive: false });

                    swipeBottom.addEventListener('touchend', function(e) {
                        const touchEndY = e.changedTouches[0].clientY;
                        const swipeDistance = touchStartY - touchEndY;
                        if (swipeDistance > minSwipeDistance) {
                            showCurrentWeather();
                        }
                        e.preventDefault();
                    }, { passive: false });
                }

                if (swipeLeft) {
                    swipeLeft.addEventListener('touchstart', function(e) {
                        touchStartX = e.changedTouches[0].clientX;
                        e.preventDefault();
                    }, { passive: false });

                    swipeLeft.addEventListener('touchend', function(e) {
                        const touchEndX = e.changedTouches[0].clientX;
                        const swipeDistance = touchEndX - touchStartX;
                        if (swipeDistance > minSwipeDistance) {
                            showHourlyWeather();
                        }
                        e.preventDefault();
                    }, { passive: false });
                }

                if (swipeRight) {
                    swipeRight.addEventListener('touchstart', function(e) {
                        touchStartX = e.changedTouches[0].clientX;
                        e.preventDefault();
                    }, { passive: false });

                    swipeRight.addEventListener('touchend', function(e) {
                        const touchEndX = e.changedTouches[0].clientX;
                        const swipeDistance = touchStartX - touchEndX;
                        if (swipeDistance > minSwipeDistance) {
                            showWeeklyWeather();
                        }
                        e.preventDefault();
                    }, { passive: false });
                }
                
                console.log('✅ Swipe gestures setup complete');
            } catch (error) {
                console.error('❌ Error setting up swipe gestures:', error);
            }
        }

        // === SETTINGS WITH ACCESSIBILITY FOCUS ===
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('leslieAccessibilitySettings');
                if (savedSettings) {
                    Object.assign(settings, JSON.parse(savedSettings));
                }
                console.log('✅ Settings loaded');
            } catch (error) {
                console.error('❌ Error loading settings:', error);
            }
            updateSettingsUI();
        }

        function saveSettings() {
            try {
                localStorage.setItem('leslieAccessibilitySettings', JSON.stringify(settings));
                console.log('✅ Settings saved');
            } catch (error) {
                console.error('❌ Error saving settings:', error);
            }
        }

        function updateSettingsUI() {
            try {
                const elements = {
                    speedSlider: document.getElementById('speechSpeedSlider'),
                    pauseSlider: document.getElementById('pauseBetweenWordsSlider'),
                    voiceSwitch: document.getElementById('speakVoiceCommandsSwitch'),
                    apiKeyInput: document.getElementById('apiKeyInput'),
                    smartRestartSwitch: document.getElementById('smartRestartSwitch'),
                    voiceActivitySwitch: document.getElementById('voiceActivitySwitch')
                };

                if (elements.speedSlider) elements.speedSlider.value = settings.speechSpeed;
                if (elements.pauseSlider) elements.pauseSlider.value = settings.pauseBetweenWords;
                if (elements.voiceSwitch) elements.voiceSwitch.checked = settings.speakVoiceCommands;
                if (elements.apiKeyInput) elements.apiKeyInput.value = settings.apiKey;
                if (elements.smartRestartSwitch) elements.smartRestartSwitch.checked = settings.smartRestart;
                if (elements.voiceActivitySwitch) elements.voiceActivitySwitch.checked = settings.voiceActivity;

                updateSpeechSpeed(settings.speechSpeed);
                updatePauseBetweenWords(settings.pauseBetweenWords);
                updateVoiceCommandSetting(settings.speakVoiceCommands);
                updateRecognitionModeUI();
                updateEnhancedSectionVisibility();
                
                console.log('✅ Settings UI updated');
            } catch (error) {
                console.error('❌ Error updating settings UI:', error);
            }
        }

        function updateSpeechSpeed(value) {
            try {
                settings.speechSpeed = parseFloat(value);
                const label = document.getElementById('speechSpeedValue');
                const slider = document.getElementById('speechSpeedSlider');
                
                if (label) {
                    const formattedValue = Math.round(parseFloat(value) * 10) / 10;
                    label.textContent = formattedValue === 1.0 ? 'Normal (1.0x)' : formattedValue + 'x';
                }
                if (slider) {
                    slider.value = value;
                }
                saveSettings();
            } catch (error) {
                console.error('❌ Error updating speech speed:', error);
            }
        }

        function updatePauseBetweenWords(value) {
            try {
                settings.pauseBetweenWords = parseFloat(value);
                const label = document.getElementById('pauseBetweenWordsValue');
                const slider = document.getElementById('pauseBetweenWordsSlider');
                
                const formattedValue = Math.round(parseFloat(value) * 10) / 10; // Fix: define formattedValue
                
                if (label) {
                    label.textContent = formattedValue + ' seconds';
                }
                if (slider) {
                    slider.value = value;
                }
                
                saveSettings();
                
                // Apply to recognition systems immediately
                console.log('♿ Updated pause between words to', formattedValue, 'seconds');
            } catch (error) {
                console.error('❌ Error updating pause between words:', error);
            }
        }

        function updateVoiceCommandSetting(checked) {
            try {
                settings.speakVoiceCommands = checked;
                const label = document.getElementById('speakVoiceCommandsLabel');
                const switchEl = document.getElementById('speakVoiceCommandsSwitch');
                
                if (label) {
                    label.textContent = 'Speak Voice Commands: ' + (checked ? 'ON' : 'OFF');
                }
                if (switchEl) {
                    switchEl.checked = checked;
                }
                saveSettings();
            } catch (error) {
                console.error('❌ Error updating voice command setting:', error);
            }
        }

        function updateRecognitionModeUI() {
            try {
                const label = document.getElementById('recognitionModeLabel');
                const modeRadios = document.querySelectorAll('input[name="recognitionMode"]');
                
                // Update radio buttons
                modeRadios.forEach(radio => {
                    radio.checked = (radio.value === settings.recognitionMode);
                });
                
                // Update label
                if (label) {
                    const modeNames = {
                        free: 'Free Mode (Zero Ping)',
                        pro: 'Pro Mode (~$0.006/min)'
                    };
                    label.textContent = 'Current: ' + (modeNames[settings.recognitionMode] || 'Free Mode (Zero Ping)');
                }
            } catch (error) {
                console.error('❌ Error updating recognition mode UI:', error);
            }
        }

        function updateRecognitionMode(mode) {
            try {
                console.log('🔧 Changing recognition mode to:', mode);
                
                // Validate API key for Pro mode
                if (mode === 'pro' && !settings.apiKey) {
                    alert('Please enter your OpenAI API key to use Pro Mode.');
                    const freeRadio = document.getElementById('modeFree');
                    if (freeRadio) freeRadio.checked = true;
                    return;
                }
                
                settings.recognitionMode = mode;
                updateRecognitionModeUI();
                saveSettings();
                
                // If currently listening, restart with new mode
                if (appState.speechPageActive && (appState.speechRecognitionActive || appState.continuousRecording)) {
                    console.log('🔄 Restarting with new mode');
                    stopSpeechRecognition();
                    setTimeout(() => {
                        startSpeechRecognition();
                    }, Math.max(1000, settings.pauseBetweenWords * 300));
                }
            } catch (error) {
                console.error('❌ Error updating recognition mode:', error);
            }
        }

        function saveApiKey(value) {
            try {
                settings.apiKey = value;
                saveSettings();
                updateEnhancedSectionVisibility();
            } catch (error) {
                console.error('❌ Error saving API key:', error);
            }
        }

        function updateEnhancedSectionVisibility() {
            try {
                const enhancedSection = document.getElementById('enhancedSection');
                if (enhancedSection && settings.apiKey) {
                    enhancedSection.classList.add('show');
                } else if (enhancedSection) {
                    enhancedSection.classList.remove('show');
                }
            } catch (error) {
                console.error('❌ Error updating enhanced section visibility:', error);
            }
        }

        function startEnhancedRecognition() {
            try {
                if (!settings.apiKey) {
                    alert('Please enter your OpenAI API key in Settings to use Pro Mode.');
                    navigateToPage('settings');
                    return;
                }
                settings.recognitionMode = 'pro';
                updateRecognitionModeUI();
                if (appState.speechPageActive) {
                    stopSpeechRecognition();
                    setTimeout(() => startSpeechRecognition(), 1000);
                }
            } catch (error) {
                console.error('❌ Error starting enhanced recognition:', error);
            }
        }

        function adjustSpeechSpeed(delta) {
            try {
                const newSpeed = Math.max(0.5, Math.min(2.0, settings.speechSpeed + delta));
                updateSpeechSpeed(newSpeed);
            } catch (error) {
                console.error('❌ Error adjusting speech speed:', error);
            }
        }

        function adjustPauseBetweenWords(delta) {
            try {
                const newPause = Math.max(0.5, Math.min(6.0, settings.pauseBetweenWords + delta));
                updatePauseBetweenWords(newPause);
            } catch (error) {
                console.error('❌ Error adjusting pause between words:', error);
            }
        }

        // === PAGE VISIBILITY HANDLING (ULTRA CONSERVATIVE) ===
        function handleVisibilityChange() {
            try {
                if (!document.hidden) {
                    console.log('📱 Page visible - ULTRA SLOW restart to completely prevent pings');
                    
                    // ULTRA slow restart when page becomes visible - completely prevent sounds
                    setTimeout(() => {
                        if (!appState.commandRecognitionActive && !appState.isCurrentlySpeaking && !commandStarting) {
                            console.log('🔄 Ultra slow restart of command recognition');
                            startZeroPingCommandRecognition();
                        }
                        
                        if (appState.speechPageActive && !appState.speechRecognitionActive && 
                            !appState.userStoppedManually && !appState.isCurrentlySpeaking && !speechStarting && !appState.continuousRecording) {
                            console.log('🔄 Ultra slow restart of speech recognition for speech page');
                            startSpeechRecognition();
                            resetSpeechPageTimeout();
                        }
                    }, Math.max(20000, settings.pauseBetweenWords * 8000)); // 20+ seconds minimum to eliminate all pings
                }
            } catch (error) {
                console.error('❌ Error handling visibility change:', error);
            }
        }

        // === DOM EVENT LISTENERS ===
        function setupDOMEventListeners() {
            try {
                // Initialize when DOM is ready
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', initApp);
                } else {
                    // DOM is already ready
                    setTimeout(initApp, 100);
                }

                // Initialize when window loads (backup)
                window.addEventListener('load', () => { 
                    if (!isInitialized) {
                        console.log('🔄 Initializing from window load event');
                        initApp(); 
                    }
                });

                // Page visibility handling with accessibility consideration
                document.addEventListener('visibilitychange', handleVisibilityChange);
                
                console.log('✅ DOM event listeners setup complete');
            } catch (error) {
                console.error('❌ Error setting up DOM event listeners:', error);
            }
        }

        // === GLOBAL WINDOW FUNCTIONS ===
        function setupGlobalFunctions() {
            try {
                // Make functions available globally for onclick handlers
                window.showCurrentWeather = showCurrentWeather;
                window.showHourlyWeather = showHourlyWeather;
                window.showWeeklyWeather = showWeeklyWeather;
                window.hideWeather = hideWeather;
                
                console.log('✅ Global functions setup complete');
            } catch (error) {
                console.error('❌ Error setting up global functions:', error);
            }
        }

        // === MAIN INITIALIZATION SEQUENCE ===
        function initializeApp() {
            console.log('🚀 Starting Leslie Speech Assistant initialization sequence...');
            
            try {
                // Setup basic components first
                setupGlobalFunctions();
                setupDOMEventListeners();
                
                console.log('✅ Leslie Speech Assistant initialization sequence complete');
            } catch (error) {
                console.error('❌ Error in initialization sequence:', error);
            }
        }

        // Start the initialization sequence immediately
        initializeApp();
    </script>
</body>
</html>
